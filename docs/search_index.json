[["index.html", "A Cartridge Case Comparison Pipeline 1 Literature Review 1.1 Preliminaries: Forensic Examinations 1.2 Forensic Comparison Pipelines 1.3 Diagnostic Tools 1.4 Automating and Improving the Cartridge Case Comparison Pipeline", " A Cartridge Case Comparison Pipeline Joseph Zemmels Abstract Algorithms to compare evidence are increasingly used in forensic examinations to supplement an examiner’s opinion with an objective measure of similarity. However, an algorithm must first be thoroughly tested under various conditions to identify its strengths and weaknesses. This experimentation is expedited for algorithms that are accessible to fellow researchers and practitioners. In this work, we discuss an algorithm to objectively measure the similarity between cartridge cases. We have designed this algorithm to be approachable for researchers and practitioners alike. Chapter 2 discusses a modularization of the algorithm into a “pipeline” that enables reproducibility, experimentation, and comprehension. Our goal in this modularization is to lay a foundation upon which improvements can be easily developed. Chapter 3 details a suite of diagnostic tools that illuminate the inner-workings of the algorithm and determine when and why the algorithm “works” correctly. These diagnostics will be useful for both researchers interested in correcting the algorithm’s behavior and for practitioners concerned with applying the algorithm to case work. Chapter 4 introduces novel pieces of the pipeline that we demonstrate are improvements to predominant methods. In particular, we introduce the Automatic Cartridge Evidence Scoring (ACES) algorithm that measures the similarity between two cartridge cases using a novel set of numeric features. 1 Literature Review 1.1 Preliminaries: Forensic Examinations A bullet casing is found at the scene of a murder. The bullet is recovered from the victim during autopsy. A handwritten letter threatening the victim is found in their pocket. The assailant’s shoeprints are discovered fleeing the area. Who left this evidence? Investigators obtain the gun, shoes, and handwriting samples of a suspect. This evidence, along with the crime scene evidence, is sent to a forensic laboratory for analysis. Forensic examiners compare the evidence to establish whether they share a common source. The suspect is charged after the examiners conclude that there is sufficient agreement between the crime scene and suspect’s samples. The procedure described above, in which evidence is analyzed to determine its origin, is called the source identification problem . Historically, forensic examiners have relied on tools (e.g., microscopes), case facts, and experience to develop an opinion on the similarity of two pieces of evidence. More recently, algorithms to automatically compare evidence and provide an objective measure of similarity have been introduced. These algorithms can be used in a forensic examination to supplement and inform the examiner’s conclusion. We propose an automatic, objective solution to the source identification problem; specifically in the context of comparing fired cartridge cases. Cartridge case comparison is a sub-discipline of Firearm and Toolmark Identification, which is reviewed in the next section. 1.1.1 Firearm and Toolmark Identification Firearm and toolmark identification involves studying markings or impressions left by a hard surface such as a firearm or screwdriver on a softer surface . For example, a barrel’s rifling leaves toolmarks on a bullet as it travels out of the gun. 1.1.1.1 The Firing Process In this section, we describe the basic process of firing a cartridge out of a handgun or rifle. A cartridge consists of a metal casing containing primer, gunpowder, and a bullet. Figure 1.1 shows a cross-section of a cartridge featuring these components . Figure 1.1: A cartridge containing primer, powder, and a bullet. The firing process is initiated by loading a cartridge into the barrel of a firearm. First, a cartridge is loaded into the back of the barrel in an area called the chamber. Figure 1.2 shows an example of a cartridge loaded into the chamber of a pistol . Note that the hammer of the pistol in Figure 1.2 is pulled to hold the firing pin under spring tension. Upon squeezing the trigger, the firing pin releases and travels forwards at a high velocity. The firing pin strikes the primer of the cartridge case, causing it to explode. Figure 1.2: Cross-section of a pistol with a chambered cartridge and drawn-back hammer. Pulling the trigger releases the firing pin which strikes the cartridge case primer. The explosion of the primer ignites the powder in the cartridge . As shown in 1.3, gas rapidly expands in the cartridge that pushes the bullet down the barrel. Simultaneously, the rest of the cartridge travels towards the back of the barrel and strikes the back wall of the barrel, known as the breech face, with considerable force. Figure 1.3: A cartridge after a firing pin has struck the primer. The explosion of the primer ignites the powder within the cartridge, causing gas to rapidly expand and force the bullet down the barrel. Any markings on the breech face are imprinted onto the cartridge case, creating the so-called breech face impressions. These impressions are analogous to a barrel’s “fingerprint” left on the cartridge case. Figure 1.4 shows cartoon examples of breech face markings that appear on cartridge cases . Figure 1.4: Examples of common breech face impression patterns. These are considered analogous to a breech face fingerprint left on the cartridge surface. Figure 1.5 shows the base of a fired cartridge . The hole to the south-east of the center of the primer is the impression left by the firing pin. Note the horizontal striated breech face markings on the primer to the left of the firing pin impression. We focus on the comparison of such markings. Figure 1.5: A fired 9mm Luger cartridge case with visible firing pin and breech face impressions. 1.1.1.2 An Overview of Firearm and Toolmark Examinations Trained firearm and toolmark examiners use a comparison microscope like the one in Figure 1.6 to examine two pieces of evidence . A comparison microscope combines the view of two compound microscopes into a single view via an optical bridge. This allows an examiner to view two microscope stages simultaneously under the same eyepiece. The right Figure 1.6 shows the view of two bullets under a comparison microscope. The white dotted line represents the split in the two fields of view. The goal of using a comparison microscope is to assess the “agreement” of the features on two pieces of evidence. Figure 1.6: A comparison microscope consists of two stages upon which evidence is placed. These stages are placed under two compound microscopes that are joined together via an optical bridge and allow for viewing of both stages simultaneously under a single eyepiece. The image on the right shows an example of a bullet viewed under a comparison microscope. Firearm examiners distinguish between three broad categories when characterizing the features of a fired bullet or cartridge case: class, subclass, and individual characteristics. Class characteristics are features associated with the manufacturing of the firearm such as the size of ammunition chambered by the firearm, the orientation of the extractor and ejector, or the width and twist direction of the barrel rifling. An early step in a forensic examination is to determine the class characteristics of the firearm of origin as they can narrow the relevant population of potential firearm sources . For example, a 9mm cartridge case must have been fired by a firearm that can chamber 9mm ammunition. If the discernible class characteristics match between two pieces of evidence, then the examiner uses a comparison microscope to compare the individual characteristics of the evidence. Individual characteristics are markings attributed to imperfections on the firearm surface due to the manufacturing process, use, and wear of the tool. For example, markings on the breech face of a barrel often form after repeated fires of the firearm. Individual characteristics are assumed to occur randomly across different firearms and therefore can be used to distinguish between two firearms. The examiner independently rotates and translates the stages of a comparison microscope to find the position where the markings on the two pieces of evidence match . An examiner concludes that the evidence originated from the same firearm if the individual characteristics are in “sufficient agreement” . Subclass characteristics exist between the macro-level class and micro-level individual characteristics. These characteristics relate to markings reproduced across a subgroup of firearms. For example, breech faces manufactured by the same milling machine may share similar markings . It can be difficult to distinguish between individual and subclass characteristics during an examination. An examiner’s decision process may be affected if the existence of subclass characteristics is suspected. Many firearm and toolmark examiners in the United States adhere to the Association of Firearm and Toolmark Examiners (AFTE) Range of Conclusions when making their evidentiary conclusions . According to these guidelines, six possible conclusions can be made in a firearm and toolmark examination: Identification: Agreement of a combination of individual characteristics and all discernible class characteristics where the extent of agreement exceeds that which can occur in the comparison of toolmarks made by different tools and is consistent with the agreement demonstrated by toolmarks known to have been produced by the same tool. Inconclusive: there are three possible inconclusive decisions 2.1 Some agreement of individual characteristics and all discernible class characteristics, but insufficient for an identification. 2.2 Agreement of all discernible class characteristics without agreement or disagreement of individual characteristics due to an absence, insufficiency, or lack of reproducibility. 2.3 Agreement of all discernible class characteristics and disagreement of individual characteristics, but insufficient for an elimination. Elimination: Significant disagreement of discernible class characteristics and/or individual characteristics. Unsuitable: Unsuitable for examination. Forensic examinations first involve an examination of a “questioned” bullet or cartridge case for identifiable toolmarks . The examiner classifies markings by their class, individual, and subclass characteristics. The examiner compares these characteristics to “known source” fires obtained from a suspect’s firearm if one is available. Otherwise, class characteristics from the questioned bullet can be used to narrow the relevant population and provide potential leads. An examiner’s decision may be used as part of an ongoing investigation or presented at trial as expert testimony. Standard operating procedures for assessing and comparing evidence differ between forensic laboratories. For example, some labs collapse the three possible inconclusive decisions into a single decision or prohibit examiners from making an elimination based on differences in individual characteristics . 1.1.2 Why Should Firearm and Toolmark Identification Change? In 2009, the National Research Council released a report assessing a number of forensic disciplines including Firearm and Toolmark analysis. The report pointed out that firearm and toolmark analysis lacked a precisely defined process and that little research had been done to determine the reliability or repeatability of the methods. Reliability refers to the ability to correctly classify evidence as originating from the same source or not. Repeatability refers to the consistency of conclusions; for example, whether an examiner makes the same conclusion if presented with the same evidence on different occasions. Two of the recommendations from this study were to establish rigorously-validated laboratory procedures and “develop automated techniques capable of enhancing forensic technologies .” A number of studies assess the reliability and repeatability of a firearm and toolmark examination (non-exhaustively: ). These studies indicate that examiners have a low error rate when comparing evidence obtained under controlled conditions (i.e., for which ground-truth is known). However, as pointed out in a 2016 report from the President’s Council of Advisors on Science and Technology, many of these studies, save , were not “appropriately designed to test the foundational validity and estimate reliability .” The report called for more properly-designed studies to establish the scientific validity of the discipline. Due to the opacity in the decision-making process, examiners are referred to as “black boxes” in a similar sense to black-box algorithms . Their evidentiary conclusions are fundamentally subjective and empirical evidence suggests that conclusions may differ if examiners are presented with the same evidence on different occasions . Examiners rarely need to provide quantitative justification for their conclusion. Even for qualitative justifications, it can be difficult to determine what the examiner is actually “looking at” to arrive at their conclusion . This suggests the need to supplement these black box decisions with transparent, objective techniques that quantitatively measure the similarity between pieces of evidence. As stated in , efforts should be made to “convert firearms analysis from a subjective method to an objective method” including “developing and testing image-analysis algorithms for comparing the similarity of tool marks.” This work focuses on the development of an algorithm for comparing breech face impressions on cartridge cases. 1.2 Forensic Comparison Pipelines Recent work in many forensic disciplines has focused on the development of algorithms to measure the similarity between pieces of evidence including glass , handwriting , shoe prints , ballistics , and toolmarks . These algorithms often result in a numerical score for two pieces of evidence. A numerical score can add more nuance to an evidentiary conclusion beyond simply stating whether the evidence originated from the same source as would be the case in binary classification. For example, a larger similarity scores implies the evidence is more similar. However, an examiner must ultimately reach one of two conclusions (or three, if admitting inconclusives). Whether a conclusion should be based solely on an algorithm’s similarity score or if an examiner should incorporate the similarity score into their own decision-making process is still up for debate . In this work we view forensic comparison algorithms as a supplement to, rather than a replacement of, the traditional forensic examination. We treat forensic comparison algorithms as evidence-to-classification “pipelines.” Broadly, the steps of the pipeline include : capturing a digital representation of the evidence, pre-processing this representation to isolate or emphasize a region of interest of the evidence, comparing regions of interest from two different pieces of evidence to obtain a (perhaps high-dimensional) set of similarity features, combining these features into a low-dimensional set of similarity scores, and defining a classification rule based on these similarity features. We add to this structure the emphasis that each step of the pipeline can be further broken-down into modularized pieces. For example, the pre-processing step may include multiple sub-procedures to isolate a region of interest of the evidence. Figure 1.7 shows two possible variations of the cartridge case comparison pipeline as well as the parameters requiring manual specification and alternative modules. The benefits of this modularization include easing the process of experimenting with different parameters/sub-procedures and improving the comprehensibility of the pipeline. Figure 1.7: Variations upon the cartridge case comparison pipeline. The first two columns detail the pipeline with different sub-procedures. The third columns shows the parameters that require manual specification at each step. The fourth column shows alternative processing steps that could replace steps in the existing pipeline. In the following sections, we detail recent advances to each of the five steps in the pipeline outlined above. We narrow our focus to advances made in comparing firearms evidence. 1.2.1 Digital Representations of Evidence Digital representations of cartridge case evidence commonly come in two forms: 2D optical images or 3D topographic scans. A common way to take 2D optical images is to take a picture of the cartridge case surface lit up under a microscope, implying a dependence on the lighting conditions under which the picture was taken. Some recent work has focused on comparing 2D optical images , although the use of 3D microscopes has recently become more prevalent to capture the surface of ballistics evidence. Using a 3D microscope allows for the scanning of surfaces at the micron (or micrometer) level under light-agnostic conditions . Figure 1.8 shows a 2D image and 3D topography of the same cartridge case primer from . Figure 1.8: A cartridge case captured using 2D confocal reflectance microscopy (left) and 3D disc scanning confocal microscopy (right). Recently, Cadre Forensicsintroduced the TopMatch-3D High-Capacity Scanner . Figure 1.9 shows a TopMatch scanner with a tray of 15 fired cartridge cases . This scanner collects images of a gel pad under various lighting conditions into which the cartridge case surface is impressed. Proprietary algorithms combine these images into a regular 2D array called a surface matrix. Elements of the surface matrix represent the relative height value of the associated surface. The physical dimensions of these scans are about 5.5 \\(mm^2\\) captured at a resolution of 1.84 microns per pixel (1000 microns equals 1 mm). Figure 1.9: The TopMatch-3D High-Capacity Scanner from Cadre Forensics . The scanner captures topographic scans of a gel pad into which a cartridge case surface is impressed. The ISO standard x3p file format is commonly used to save 3D scans . An x3p is a container consisting of a single surface matrix representing the height values of the surface and metadata concerning the parameters under which the scan was taken as shown in Figure 1.10 . A number of studies suggest that 3D topographic scans of cartridge case surfaces lead to more accurate classifications than 2D optical images of the same evidence . Figure 1.10: The hierarchy of information stored in the x3p file format for both bullet and cartridge case evidence. 1.2.2 Pre-processing Procedures for Forensic Data After obtaining a surface’s digital representation, we next want to isolate regions of the surface containing distinguishable markings. Figure 1.8 shows an example of a 2D image and 3D scan of the same cartridge case. In both representations, the corners of these arrays include regions of the cartridge case surface outside of the primer. The center of the cartridge case primer contains an impression left by the firing pin during the firing process. We wish to isolate the annular breech face region around the firing pin impression from the rest of the captured surface. Both the 2D optical and 3D topographic representations of cartridge case surfaces are fundamentally pictorial in nature. As such, breech face impression isolation commonly relies on image processing and computer vision techniques. uses a combination of histogram equalization, Canny edge detection, and morphological operations to isolate breech face impressions in 2D images. A Gaussian filter is another common tool to emphasize breech face impressions. apply a low-pass Gaussian filter to remove noise via a Gaussian-weighted moving average operation. and use a bandpass Gaussian filter to simultaneously remove noise and unwanted global structure from the scan. and use a “robust” variant of the Gaussian filter to omit outliers from the scan . Instead of automatic procedures, others have used subjective human intervention to isolate the breech face impressions. For example, performed “manually trimming to extract the breech face impression of interest” on a set of cartridge case scans. In , examiners manually identify the borders of the breech face impression region by placing points around an image of the cartridge case primer. 1.2.3 Forensic Data Feature Extraction After isolating the breech face impressions, we compare two pre-processed cartridge case scans and compute a set of similarity features. Because the cartridge cases at this point are represented as high-dimensional matrices, this process can be thought of as a dimensionality reduction of the high-dimensional surface arrays to a set of similarity statistics. A variety of features have been proposed to quantify the similarity between two cartridge case surface arrays. propose calculating the cross-correlation function (CCF) value between two cartridge cases across a grid of rotations. The cross-correlation function measures the similarity between two matrices for every translation of one matrix against the other. For two matching cartridge cases, we assume that the CCF will be largest after aligning the cartridge cases surfaces by their shared breech face impressions. Conversely, we expect the CCF to be relatively small for two non-matching cartridge cases no matter the alignment. propose combining the CCF between two aligned scans with the element-wise median Euclidean distance and median difference between the normal vectors at each point of the surface. and applied Principal Component Analysis to reduce these three features down to two principal components for the sake of fitting a 2D kernel density estimator. Pertinent to this work is the cell-based comparison procedure originally outlined in . The underlying assumption of is similar to that of : that two matching cartridge cases will exhibit higher similarity when they are close to being correctly aligned. While measured similarity using the CCF between the two full scans, proposes partitioning the scans into a grid of “correlation cells” and counting the number of similar cells between the two scans. The rationale behind this procedure is that many cartridge case scans have only a few regions with discriminatory markings. As such, comparing full scans may result in a lower correlation than if one were to focus on the highly-discriminatory regions. In theory, dividing the scans into cells allows for the identification of these regions. After breaking a scan into a grid of cells, each cell is compared to the other scan to identify the rotation and translation, known together as the registration, at which the cross-correlation is maximized. assumes that the cells from a truly matching pair of cartridge cases will “agree” on their registration in the other scan. referred to the procedure of counting the number of similar cells the “Congruent Matching Cells” method. Chapter 2 contains more details of this procedure. 1.2.4 Similarity Scores &amp; Classification Rules for Forensic Data Following feature extraction, the dimensionality of these features is further reduced to a low-dimensional, usually univariate, similarity score. We can define a decision boundary based on the value of the similarity score to classify cartridge case pairs as matching or non-matching. After calculating the CCF across various possible registrations, propose using the maximum observed CCF value as the univariate similarity score. They perform binary classifications by setting a CCF threshold above which pairs are classified as “matches” and below which as “non-matches.” proposes setting a CCF cut-off that maximizes the precision and recall in a training set of pairwise comparisons. use a training set to fit two 2D kernel density estimates to a set of features from matching and non-matching comparisons. Using these estimates, they compute a score-based likelihood ratio (SLR), which can be interpreted as a similarity score . For the Congruent Matching cells method, proposes using the number of cells that agree on a registration, the “congruent matching” cells, as a similarity score. The criteria used to define “congruent matching” cells has changed across papers and will be discussed in greater detail in Chapter 2. The authors of these papers have consistently used six congruent matching cells as a decision boundary to distinguish matching and non-matching cartridge case pairs. applies the Density-Based Spatial Clustering of Applications with Noise (DBSCAN) algorithm to the features from the cell-based comparison procedure to determine if any clusters form amongst the per-cell estimated registration values. This is based on the assumption that any cells that come to a consensus on their registration should form a cluster in translation \\((x,y)\\) and rotation \\(\\theta\\) space. proposes a binary classifier based on whether any clusters are identified by the DBSCAN algorithm . If a cluster is found for a particular pairwise comparison, then that pair is classified as a “match” and otherwise as a “non-match.” Apart from the algorithms described in and , the authors of these comparison algorithms have not provided publicly available code or data. As such, although the results reported in associated papers are promising, it is difficult or impossible for other researchers to verify or reproduce the findings. Results must be reproducible to be accepted by others in any scientific domain. In the next section, we discuss recent challenges and opportunities in computationally reproducible research. 1.2.5 Reproducibility of Comparison Pipelines defines reproducibility as “obtaining consistent computational results using the same input data, computational steps, methods, code, and conditions of analysis.” While not exact in their definition of “consistent,” the authors assert that, barring a few exceptions, it is reasonable to expect that the results obtained by a second researcher, after applying the exact same processing steps to the exact same data, be the exact same as the original results. In either case, they assert that “a study’s data and code have to be available in order for others to reproduce and confirm results.” Given data and code, researchers are able to verify the results, incorporate the materials into their own research, and improve or accelerate discovery . A number of studies indicate that computationally reproducible research is sparse across various disciplines. and studied the reproducibility of articles sampled from the Journal of Computational Physics and the journal Science, respectively. In the former, found that zero of 306 randomly selected articles from the Journal of Computaional Physics were “straightforward to reproduce with minimal effort” and, at best, that five articles were “reproducible after some tweaking.” In the latter, found that only 3 of 204 randomly selected articles from Science were “straightforward to reproduce with minimal effort;” despite a journal policy requiring that all code and data used in the paper be made available to any reader. Similar findings were found in (29 of 59 economic papers reproducible), (zero of 268 biomedical papers provided raw data and 1 in 268 linked to a full study protocol), (50% or more published articles include data or code in only 27 of 333 economics journals), and (24 of 400 AI conference papers included code). A common recommendation amongst these authors is to establish of rigorous tools and standards to promote reproducibility. This includes making code and data used in a paper easily-accessible to readers. Infrastructure already exists to ease the process of developing, maintaining, and sharing open-source code and data. Data repositories such as the NIST Ballistics Toolmark Research Database provide open access to raw data. discuss the use of package managers such as Conda (https://anaconda.org/anaconda/conda), container software such as Docker (https://www.docker.com/), and virtual machine software to preserve the entire data analysis environment in-perpetuity. For situations in which VMs or containers aren’t available, software such as the manager R package allows users to “compare package inventories across machines, users, and time to identify changes in functions and objects .” reference repositories like Bioconductor that make it easy to document and distribute code. Further, software such as the knitr R package enable “literate programming” in which prose and executed code can be interwoven to make it easier to understand the code’s function. These tools make data, code, and derivative research findings more accessible, in terms of both acquisition and comprehensibility, to consumers and fellow researchers. 1.3 Diagnostic Tools Forensic examiners often provide expert testimony in court cases. As part of this testimony, an examiner is allowed to provide facts about the outcome of a forensic examination and their opinion about what the results mean. A party to a court may challenge the examiner on the validity of the underlying scientific method or whether they interpreted the results correctly . In these situations, examiners need to explain the process by which they reached an evidentiary conclusion to the fact finders of the case; namely, the judge or jury. As algorithms are more often used in forensic examinations, the technical knowledge required to understand and explain an algorithm to lay-people has increased. Indeed, even the most effective algorithms may be moot if an examiner can’t explain the algorithm in their testimony. While in some cases the authors of the algorithm have been willing to provide testimony to establish the validity of the algorithm , this will become less viable as algorithms become more prevalent. The resources required to educate examiners on the theory and implementation of highly technical algorithms makes additional training seem currently implausible. An alternative is to develop algorithms from the ground-up to be intuitive for examiners to understand and explain to others. Explainability refers to the ability to identify the factors that contributed to the results of an algorithm . For example, understanding why a classifier predicted one class over another. Diagnostics are tools to explain or justify the behavior of a model or algorithm in specific instances. Myriad diagnostic tools exist to explain the results of an algorithm. These range from identifying instances of the training set that illuminate how the model operates to fitting more transparent models that accurately approximate the complex model to explaining the behavior of the algorithm in a small region of interest of the prediction space . Many of these methods require additional technical knowledge to interpret these explanations. 1.3.1 Visual Diagnostics A less technical approach is to use visualizations that facilitate understanding of model behavior. Properly constructed visuals enable both exploratory data analysis and diagnostics , which are critical steps in the data analysis process for anticipating and assessing model fit. Given that many of the procedures by which cartridge case evidence is captured, processed, and compared are based on image processing techniques, a visual diagnostic is an intuitive mode of explanation for researchers and lay-people alike. As stated in , “graphical methods tend to show data sets as a whole, allowing us to summarize the behavior and to study detail. This leads to much more thorough data analyses.” Numerical statistics summarize the behavior of data, but miss the detail referenced in Cleveland’s quote . To illustrate this, consider the famous data sets from known as Anscombe’s quartet. The two variables in each data set are plotted against one another in Figure 1.11. There are clear differences in the relationship between x and y across these four data sets. Figure 1.11: A visualization of Anscombe’s quartet. Despite there being obvious differences between these four data sets, their summary statistics are nearly identical Despite these differences, Table ?? shows that summary statistics, namely the first two moments, are identical. This demonstrates that visual diagnostics can be more effective at uncovering data behavior than summary statistics (at least low-order moments). Given the pivotal role that visual diagnostics play in the data analysis pipeline, we now consider best practices in creating data visualizations. Human brains are wired for seeing patterns and differences, and for understanding spatial relationships from this . As such, an effective visual diagnostic or data visualization is one that conveys patterns quickly and easily, and with minimal scope for understanding. Arising originally from a psychological theory of perception, the Gestalt Laws of Perceptual Organization summarize important considerations when constructing statistical graphics. The Gestalt laws are as follows: Pragnanz - the law of simplicity: Every stimulus pattern is seen in such a away that the resulting structure is as simple as possible. Proximity: Things that are near each other appear to be grouped together. Good Continuation: Points that, when connected, result in straight or smoothly curving lines are seen as belonging together, and the lines tend to be seen in such a way as to follow the smoothest path. Similarity: Similar things appear to be grouped together. Common Region: Elements that are within the same region of space appear to be grouped together. Uniform Connectedness: A connected region of visual properties, such as the lightness, color, texture, or motion, is perceived as a single unit. Synchrony: Visual events that occur at the same time are perceived as belonging together. Common Fate: Things that are moving in the same direction appear to be grouped together. Familiarity: Things that form patterns that are familiar or meaningful are likely to become grouped together. These laws provide guidance on how to construct a visual that concisely conveys a pattern or difference in data. For data visualization, additional laws include : Use and Effective Geometry: Choose a geometry (shape and features of a statistical graphic) that is appropriate to the data. Colors Always Mean Something: Colors in visuals can convey groupings or a range of values. Figure 1.12 depicts a case study of the Gestalt principles in practice. The plot shows the weight over time of chicks fed one of two experimental diets . Individual points represent the weight of a single chick on a particular day. Connected points represent the weight for a single chick over time. This is an example of using an effective geometry (point &amp; line graph to represent time series) along with the Gestalt law of Good Continuation. We further apply the Gestalt law of Common Region to facet the data set into plots based on diet. This implicitly communicates to the audience that the weights of two diet groups of chicks is expected to differ. Indeed, appealing to the Gestalt law of Uniform Connectedness, the “motion” of the grouped time series suggests that chicks given Diet 2 tend to gain weight more rapidly than those given Diet 1. This may suggest a particular modeling structure for these time series (e.g., diet fixed effect) or the need to assess the experimental design to ensure that the assumption that the chicks were randomly sampled from the same population is appropriate. We see how such a plot can be used for both exploratory data analysis or as a post-hoc diagnostic tool. Alternative to faceting, the time series from these two diet groups could be combined into a single plot and distinguished by color. Figure 1.12: An example of a statistical graphic that uses the Gestalt Laws of Perceptual Organization to communicate data findings. The R programming language provides a variety of tools to create visual diagnostics. Among the most robust of these tools is the ggplot2 package . This package extends the “Grammar of Graphics” introduced in to provide a user-friendly structure to create statistical graphics. We use the + operator to “layer” features of a statistical graphic (e.g., elements, transformations, guides, labels) on a blank canvas. 1.13 along with the accompanying code chunk demonstrates how to create a residual plot from a simple linear regression using the ggplot2 package. This visual diagnostic allows the analyst or audience to determine whether the homoscedasticity or linear form assumptions underlying simple linear regression are met. For those willing to learn the “grammar,” the code used to create these statistical graphics can easily be re-used and tweaked to fit a specific application. 1 lmFit &lt;- lm(formula = rating ~ complaints,data = datasets::attitude) library(ggplot2) ggplot(data = data.frame(Complaints = datasets::attitude$complaints, Residuals = lmFit$residuals)) + geom_point(aes(x = Complaints,y = Residuals)) + geom_hline(yintercept = 0,linetype = &quot;dashed&quot;) + labs(x = &quot;% in-favor of handling of employee complaints&quot;) Figure 1.13: An example of using the ggplot2 package to construct a residual plot from a simple linear regression. The features of the statistical graphic are combined layer-by-layer using the + operator as we see in the accompanying code chunk. Properly constructed visual diagnostics provide the audience with a nuanced yet intuitive explanation of the behavior of a model or algorithm that summary diagnostic statistics may not convey. Tools like the ggplot2 package provide a coherent, thorough infrastructure for creating such visual diagnostics. However, the tools discussed thus far are useful for creating static visualizations. In the next section, we discuss the benefits of making a visual diagnostic interactive to user input. 1.3.2 Interactive Diagnostics Interactive diagnostic tools encourage both expert and lay users to engage with an analysis pipeline that otherwise may be technically or conceptually inaccessible. Rather than answering a question posed by the author of a plot as a static plot does, such interactive diagnostic tools enable the audience to formulate and answer their own questions. This leads to deeper engagement with the data . While the ggplot2 package eases the process of constructing visual diagnostics, software such as the shiny R package enables the consumer of the diagnostic to interact with the visualizations and underlying data. The shiny package provides tools for using R to build web applications run on HTML, CSS, and JavaScript. Among other functionality, these applications allow users to upload or create their own data, set parameters for an analysis, interact with visualizations or data sets (e.g., by hovering to display a tooltip), and export their analyses in various file formats . Several recently-released software provide interactive diagnostic applications for firarms and toolmarks evidence. Most notable of these software is the Virtual Comparison Microscopy application from Cadre Forensics. In contrast to traditional Light Comparison Microscopy (LCM) that uses a comparison microscope, this software displays digital representations of the cartridge case surface on a computer screen. Figure 1.14 shows a screenshot of comparing two cartridge case surfaces . The functionality shown allows the user to manually annotate the surfaces of the two cartridge cases to identify similar and different markings. For example, the user has selected a shade of blue to represent similarities between the two surfaces. Conversely, shades of yellow and red represent differences between the two surfaces. This sort of interactivity allows the user to customize their analysis more effectively than they could with a static visualization. Further, we can save a history of the annotations for further analysis. These annotations are a visual diagnostic tool that allows others to understand the specific patterns that the examiner looks at during an examination. Another major benefit of using VCM over LCM is the ability to share scans over the internet rather than sending the physical specimen to another lab, which takes time and may damage the specimen. , , and all demonstrate that performing forensic examinations using such VCM technology yields equally, if not more, accurate conclusions compared to traditional LCM methods. Figure 1.14: A screenshot of the TopMatch-3D Virtual Comparison Microscopy software. In this example, similar and different markings on the cartridge case scans are manually annotated by the user using shades of blue and yellow/red, respectively. In Chapter 3, we introduce a suite of static and interactive visual diagnostic tools. We discuss how these visual diagnostic tools can be used by both researchers and practitioners to understand the behavior of automatic cartridge case comparison algorithms. 1.4 Automating and Improving the Cartridge Case Comparison Pipeline In this section, we review preliminaries needed to understand various sub-routines of the cartridge case comparison pipeline. 1.4.1 Image Processing Techniques We first review image processing and computer vision algorithms used in cartridge case comparison algorithms. Throughout this section, let \\(A, B \\in \\mathbb{R}^{k \\times k}\\) denote two images for \\(k &gt; 0\\). We use lowercase letters and subscripts to denote a particular value of a matrix: \\(a_{ij}\\) is the value in the \\(i\\)-th row and \\(j\\)-th column, starting in the top-left corner, of matrix \\(A\\). In our application, \\(A\\) and \\(B\\) represent the surface matrices of two cartridge cases. 1.4.1.1 Image Registration Image registration involves transforming image \\(B\\) to align best with image \\(A\\) (or vice versa) . In our application, this transformation is composed of a discrete translation \\((m^*,n^*) \\in \\mathbb{Z}^2\\) and rotation by \\(\\theta^* \\in [-180^\\circ, 180^\\circ]\\). Together, we refer to \\((m^*,n^*,\\theta^*)\\) as the “registration” of image \\(B\\) to \\(A\\). To determine the optimal registration, we calculate the cross-correlation function between \\(A\\) and \\(B\\), denoted \\((A \\star B)\\), which measures the similarity between \\(A\\) and \\(B\\) for every possible translation of \\(B\\). The CCF between \\(A\\) and \\(B\\) is a 2D array of dimension \\(2k - 1 \\times 2k - 1\\) where the value of the \\(m,n\\)-th element is given by: \\[ (a \\star b)_{mn} = \\sum_{i=1}^k \\sum_{j=1}^k a_{mn} \\cdot b_{i + m,j + n} \\] where \\(1 \\leq m,n \\leq 2k -1\\). The value \\((a \\star b)_{mn}\\) quantifies the similarity between \\(A\\) and \\(B\\) after \\(B\\) is translated \\(m\\) elements horizontally and \\(n\\) elements vertically. A natural choice for aligning \\(A\\) and \\(B\\) is the translation that maximizes the CCF. However, we must also consider that \\(B\\) may also need to be rotated to align optimally with \\(A\\). We therefore compute the maximum CCF value across a range of rotations of \\(B\\). Let \\(B_\\theta\\) denote \\(B\\) rotated by an angle \\(\\theta\\) and \\(b_{\\theta_{mn}}\\) the \\(m,n\\)-th element of \\(B_\\theta\\). Then the estimated registration \\((m^*, n^*, \\theta^*)\\) is: \\[ (m^*, n^*, \\theta^*) = \\arg \\max_{m,n,\\theta} (a \\star b_{\\theta})_{mn}. \\] In practice, we consider a discrete range of rotations \\(\\Theta \\subset [-180^\\circ, 180^\\circ]\\). The registration procedure is given by: For each \\(\\theta \\in \\pmb{\\Theta}\\): 1.1 Rotate image \\(B\\) by \\(\\theta\\) to obtain \\(B_\\theta\\). 1.2 Calculate the CCF between \\(A\\) and \\(B_\\theta\\). 1.3 Determine the translation \\([m_{\\theta}^*,n_{\\theta}^*]\\) at which the CCF is maximized. Also, record the CCF value associated with this translation. Across all \\(\\theta \\in \\Theta\\), determine the rotation \\(\\theta^*\\) at which the largest CCF value is achieved. The estimated registration consists of rotation \\(\\theta^*\\) and translation \\([m^*,n^*] \\equiv [m_{\\theta^*}^*,n_{\\theta^*}^*]\\). In this instance, we refer to image \\(A\\) as the “reference” and \\(B\\), the image aligned to the reference, as the “target.” We represent the transformation to register \\(B\\) to \\(A\\) element-wise where the index \\(i,j\\) maps to \\(i^*,j^*\\) by: \\[ \\begin{pmatrix} j^* \\\\ i^* \\end{pmatrix} = \\begin{pmatrix} n^* \\\\ m^* \\end{pmatrix} + \\begin{pmatrix} \\cos(\\theta^*) &amp; -\\sin(\\theta^*) \\\\ \\sin(\\theta^*) &amp; \\cos(\\theta^*) \\end{pmatrix} \\begin{pmatrix} j \\\\ i \\end{pmatrix}. \\] Under this transformation, the value \\(b_{ij}\\) now occupies the the \\(i^*,j^*\\)-th element. In practice, we use nearest-neighbor interpolation meaning \\(i^*\\) and \\(j^*\\) are rounded to the nearest integer. Based on the definition given above, the CCF is computationally taxing. In image processing, it is common to use an implementation based on the Fast Fourier Transform . This implementation leverages the Cross-Correlation Theorem, which states that for images \\(A\\) and \\(B\\) the CCF can be expressed in terms of a frequency-domain pointwise product: \\[ (A \\star B)[m,n] = \\mathcal{F}^{-1}\\left(\\overline{\\mathcal{F}(A)} \\odot \\mathcal{F}(B)\\right)[m,n] \\] where \\(\\mathcal{F}\\) and \\(\\mathcal{F}^{-1}\\) denote the discrete Fourier and inverse discrete Fourier transforms, respectively, and \\(\\overline{\\mathcal{F}(A)}\\) denotes the complex conjugate . Because the product on the right-hand side is calculated pointwise, this result allows us to trade the moving sum computations from the definition of the CCF for two forward Fourier transformations, a pointwise product, and an inverse Fourier transformation. The Fast Fourier Transform (FFT) algorithm can be used to reduce the computational load considerably. Figure 1.15 shows an example of two images \\(A\\) and \\(B\\) of dimension \\(100 \\times 100\\) and \\(21 \\times 21\\), respectively. The white boxes in both of the images are of dimension \\(10 \\times 10\\). The box in image A is centered on index [30,50] while the box in image B is centered on index [11,11]. The right image shows the result of calculating the CCF using image \\(A\\) as reference and \\(B\\) as template. The CCF achieves a maximum of 1, indicating a perfect match, at the translation value of \\([m^*,n^*] = [22,-2]\\). This means that if image B were overlaid onto image A such that their center indices coincided, then image B would need to be shifted 22 units “up” and 2 units “left” to match perfectly with image A. Figure 1.15: (Left) A reference image \\(A\\) and template image \\(B\\) both featuring a white box of dimension \\(10 \\times 10\\). (Right) The cross-correlation function (CCF) between \\(A\\) and \\(B\\). The index at which the CCF is maximized represents the translation at which \\(A\\) and \\(B\\) are most similar. 1.4.1.2 Gaussian Filters In image processing, a Gaussian filter (equivalently, blur or smoother) is a mathematical operator that imputes the values in an image using a locally-weighted sum of surrounding values. We use a lowpass Gaussian filter to smooth the surface values of a cartridge case scan. The weights are dictated according to the Gaussian function of a chosen standard deviation \\(\\sigma\\) given by: \\[ f(n,m;\\sigma) = \\frac{1}{2\\pi\\sigma^2} \\exp\\left(-\\frac{1}{2\\sigma^2}(n^2 + m^2)\\right). \\] It is common to populate a 2D array with the values of the Gaussian function treating the center index as the origin. Such an array is called a kernel. An example of a \\(3 \\times 3\\) Gaussian kernel \\(K\\) with standard deviation \\(\\sigma = 1\\) is given below. \\[ K = \\begin{pmatrix} 0.075 &amp; 0.124 &amp; 0.075 \\\\ 0.124 &amp; 0.204 &amp; 0.124 \\\\ 0.075 &amp; 0.124 &amp; 0.075 \\end{pmatrix}. \\] For an image \\(A\\) and Gaussian kernel \\(K\\) with standard deviation \\(\\sigma\\), the lowpass filtered version of \\(A\\), denoted \\(A_{lp,\\sigma}\\) is given by: \\[ A_{lp,\\sigma}[m,n] = \\mathcal{F}^{-1}\\left(\\mathcal{F}(A) \\odot \\mathcal{F}(K)\\right)[m,n]. \\] This operation, known as convolution, is extremely similar to the calculation of the CCF defined in the Image Registration section . From left to right, Figure 1.16 shows an image \\(A\\) of a box injected with Gaussian noise (noise standard deviation \\(\\sigma_n = 0.3\\)) followed by the application of various Gaussian filters. In the middle of Figure 1.16, we see that the lowpass filter (kernel standard deviation \\(\\sigma_k = 2\\)) recovers some of the definition of the box by “smoothing” some of the Gaussian noise. If a lowpass filter smooths values in an image, then a highpass filter performs a “sharpening” operation. For an image \\(A\\) and kernel standard deviation \\(\\sigma\\), the highpass filtered version \\(A_{hp}\\) can be defined as: \\[\\begin{align*} A_{hp,\\sigma} = A - A_{lp,\\sigma}. \\end{align*}\\] The highpass filter therefore removes larger-scale (smooth) structure from an image and retains high-frequency structure such as noise or edges. The fourth facet of Figure 1.16 shows a highpass-filtered image \\(A\\) . The smooth interior of the box is effectively removed from the image while the edges are preserved. Finally, a bandpass Gaussian filter simultaneously performs highpass sharpening and lowpass smoothing operations. Generally, the standard deviation of the highpass kernel will be considerably larger than that of the lowpass kernel. This leads to retaining sharp edges while also reducing noise. An example of a bandpass filtered image \\(A\\) is shown in Figure 1.16. The edges of the box are better-preserved compared to the lowpass filter figure while the interior of the box is better-preserved compared to the highpass filter figure. Figure 1.16: An image \\(A\\) of a box with Gaussian noise undergoing a lowpass, highpass, and bandpass filter operation. Variations on the standard Gaussian filter include the “robust” Gaussian regression filter. This filter fluctuates between a filter step, which applies a Gaussian filter, and outlier step, which identifies and omits outlier observations from the next filter step . Another alternative, the “edge preserving” filter, adapts the kernel weights when approaching the boundary of an image to mitigate so-called boundary effects . We use Gaussian filters to change the values on the interior of a cartridge case surface to better emphasize breech face impressions. In the next section, we discuss applying morphological operations to change the values on the edges of a cartridge case surface. 1.4.1.3 Morphological Operations Mathematical morphology refers to a theory and collection of image processing techniques for geometrical structures . In our application, these geometrical structures are cartridge case scans; specifically, binarized versions of these scans representing whether a particular pixel contains part of the cartridge case surface. We discuss this in greater detail in Chapter 2. Two fundamental operations in mathematical morphology are dilation and erosion . For our purposes, these are both set operations on black and white, encoded as 0 and 1 respectively, images. We call the set of black and white pixels the “background” and “foreground” of the image, respectively. For an image \\(A\\), let \\(W = \\{(m,n) : A_{mn} = 1\\}\\) denote the foreground of \\(A\\). An example of a \\(7 \\times 7\\) binary image \\(A\\) with \\(W = \\{(3,3),(3,4),(3,5),(4,3),(4,4),(4,5),(5,3),(5,4),(5,5)\\}\\) is given below. \\[ A = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\end{pmatrix} \\] A structuring element is a second, typically small, array \\(B\\) of ones that affects the amount of dilation or erosion applied to \\(W\\) within \\(A\\). For simplicity, the indexing of the structuring element uses the center element as the index origin. For example, a \\(3 \\times 3\\) structuring element is given by \\(B = \\{(-1,-1),(-1,0),(-1,1),(-1,0),(0,0),(0,1),(1,-1),(1,0),(1,1)\\}\\) or visually: \\[ B = \\begin{pmatrix} 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 \\end{pmatrix} \\] As the name suggests, a dilation grows the region \\(W\\) within image \\(A\\) by replacing 0-valued pixels that border \\(W\\) with 1. The structuring element \\(B\\) dictates which pixels are replaced with 1. We define the dilation of \\(W\\) by \\(B\\), denoted \\(W \\oplus B\\), element-wise: \\[ W \\oplus B = \\{[m,n] \\in A : [m,n] = [i + k,j + l] \\text{ for } [i,j] \\in W \\text{ and } [k,l] \\in B\\} \\] In our example, \\[W \\oplus B = \\{[3,2],[3,3],[3,4],[3,5],[3,6],[4,2],[4,3],[4,4],[4,5],[4,6],[5,2],[5,3],[5,4],[5,5],[5,6]\\}\\] or visually: \\[ W \\oplus B = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\end{pmatrix}. \\] The dilation operation by this \\(B\\) has the effect of growing the region \\(W\\) inside of \\(A\\) by one index in each direction. In contrast, erosion has the effect of shrinking \\(W\\). The erosion of \\(W\\) by \\(B\\) is: \\[ A \\ominus B = \\{[m,n] \\in A: [m,n] + [k,l] \\in A \\text{ for every } [k,l] \\in B\\}. \\] Using the same example as above, \\(W \\ominus B = \\{[3,3]\\}\\) or visually: \\[ W \\ominus B = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\end{pmatrix}. \\] Erosion by this \\(B\\) shrinks the region \\(W\\) in \\(A\\) by one index in each direction. Figure 1.17 shows our example represented using black and white pixels. In practice, the foreground set \\(W\\) may contain disconnected regions to which dilation or erosion can be independently applied. Figure 1.17: A \\(7 \\times 7\\) image \\(A\\) featuring a \\(3 \\times 3\\) box undergoing dilation and erosion by a \\(3 \\times 3\\) structuring element \\(B\\). This concludes our review of image processing techniques we use in subsequent chapters. Next, we discuss a clustering procedure used in Chapter 4 to calculate similarity features. 1.4.2 Density-Based Spatial Clustering of Applications with Noise The Density-Based Spatial Clustering of Applications with Noise (DBSCAN) algorithm is a clustering procedure that assigns observations to clusters if they are in a region of high observation density . As we will see, the DBSCAN algorithm does not require the user to pre-specify the number of expected clusters as is required in common clustering algorithms like K-means. Further, the algorithm does not require that all points be assigned to a cluster. Let \\(D\\) represent a \\(n \\times p\\) data set (\\(n\\) observations, each of dimension \\(p\\)) and let \\(x,y,z \\in D\\) denote three observations. The DBSCAN algorithm relies on the notion of \\(\\epsilon\\)-neighborhoods. Given some neighborhood radius \\(\\epsilon \\in \\mathbb{R}\\) and distance metric \\(d\\), \\(y\\) is in the \\(\\epsilon\\)-neighborhood of \\(x\\) if \\(d(x,y) \\leq \\epsilon\\). The \\(\\epsilon\\)-neighborhood of \\(x\\) is defined as the set \\(N_{\\epsilon}(x) = \\{y \\in D : d(x,y) \\leq \\epsilon\\}\\). Given a minimum number of points \\(Minpts \\in \\mathbb{N}\\) (notation used in ), observation \\(x\\) is called a core point with respect to \\(\\epsilon\\) and \\(Minpts\\) if \\(|N_{\\epsilon}(x)| \\geq Minpts\\). Core points are treated as the “seeds” of clusters in the DBSCAN algorithm. The user must select values of \\(\\epsilon\\) and \\(Minpts\\). Figure 1.18 shows an example of a data set \\(D \\in \\mathbb{R}^{10 \\times 2}\\). We represent the 10 observations in \\(D\\) on the Cartesian plane. An \\(\\epsilon\\)-neighborhood using the Euclidean distance metric and \\(\\epsilon = 3\\) is drawn around an observation \\(x\\) located at \\((3,2)\\). Points inside the circle are neighbors of \\(x\\). If, for example, \\(Minpts = 2\\), then \\(x\\) would be considered a core point. Figure 1.18: An \\(\\epsilon\\)-neighborhood around a observation located at \\((3,2)\\) for \\(\\epsilon = 3\\). Points are colored blue if they are neighbors to this observation and red otherwise. introduces two relational notions, density-reachability and density-connectivity, to identify regions of high observation density. A point \\(y\\) is directly density-reachable to a point \\(x\\) if \\(x\\) is a core point and \\(y \\in N_{\\epsilon}(x)\\). In Figure 1.18, the observation located at \\((1,0)\\) is directly density-reachable to the observation located at \\((3,2)\\). More broadly, a point \\(x_m\\) is density-reachable to a point \\(x_1\\) if there exists a chain of observations \\(x_1,x_2,...,x_{m-1},x_m\\) such that \\(x_{i+1}\\) is directly density-reachable from \\(x_i\\), \\(i = 1,...,n\\). Density reachability captures the notion of “neighbors of neighbors” for core points. The DBSCAN algorithm agglomerates density-reachable points into single clusters. Figure 1.19 highlights three points \\((1,0), (3,2)\\), and \\((4,4)\\). Using \\(\\epsilon = 3\\) and \\(Minpts = 2\\), we see that all three of these points are core points. Further, the points at \\((1,0)\\) and \\((4,4)\\) are density-reachable by way of the point \\((3,2)\\). Figure 1.19: An example of three points that are density-reachable with respect to \\(\\epsilon = 3\\) and \\(Minpts = 2\\). Finally, a point \\(y\\) is density-connected to a point \\(x\\) with respect to \\(\\epsilon\\) and \\(Minpts\\) if there exists a point \\(z\\) such that both \\(x\\) and \\(y\\) are density-reachable to \\(z\\) (with respect to \\(\\epsilon\\) and \\(Minpts\\)). While density-reachability requires that all points in-between two points also be core points, density-connectivity extends the notion of “neighbors of neighbors” to include points that are merely within the neighborhood of density-reachable points. Figure 1.20 illustrates how the points located at \\((4,7)\\) and \\((0,-2)\\) are density-connected but not density-reachable. Figure 1.20: An example of two points that are density-connected, but not density-reachable, with respect to \\(\\epsilon = 3\\) and \\(Minpts = 2\\). A cluster \\(C \\subset D\\) with respect to \\(\\epsilon\\) and \\(Minpts\\) satisfies the following conditions: \\(\\forall x,y\\): if \\(x \\in C\\) and \\(y\\) is density-reachable from \\(x\\) with respect to \\(\\epsilon\\) and \\(Minpts\\), then \\(y \\in C\\). \\(\\forall x,y \\in C\\): \\(x\\) is density-connected to \\(y\\) with respect to \\(\\epsilon\\) and \\(Minpts\\). For a data set \\(D\\), the DBSCAN algorithm determines clusters based on the above definition. Points not assigned to a cluster are classified as noise points. The algorithm halts once all points are assigned to a cluster or classified as noise. Figure 1.21 shows the labels return by DBSCAN for the example considered above with respect to \\(\\epsilon = 3\\) and \\(Minpts = 2\\). The algorithm finds a cluster of seven points, colored blue, and classifies three points as noise, colored red. Figure 1.21: Cluster labeling for 10 data points using the DBSCAN algorithm with parameters \\(\\epsilon = 3\\) and \\(Minpts = 2\\). Seven points are assigned to a single cluster and the remaining three are classified as noise. 1.4.3 Implementation Considerations In the computational sciences, it is one thing to publish code along with research findings. Publicly-available code and data make results accessible in terms of acquisition. It is much more challenging to make code conceptually accessible to others. The former allows others to obtain the same results under the same programming conditions while the latter empowers others to actually engage with and potentially improve upon individual pieces of the algorithm. In any data analysis pipeline, the procedural details may be obscured as the goals of the analysis become more sophisticated. It is therefore worthwhile to design tools that make the data analysis process both easier to implement and understand . Our implementation of the cartridge case comparison pipeline adheres to the “tidy” principles of design . The “tidyverse” is a collection of R packages that share an underlying design philosophy and structure. Knowledge and skills learned while using one tidy package can be applied to others. The four principles of a tidy API are: Reuse existing data structures. For example, users do not need to learn new data attributes or compatible functions if a package reuses existing data structures. Compose simple functions with the pipe. The pipe operator allows the output of one function to be passed as input to another without assigning a new variable. We incrementally transform data as they move from one function to another rather than drastically transforming the data in a single call. Embrace functional programming. The functional programming paradigm encourages immutability of objects, meaning data passed as input to a function are not changed. Rather, the function makes a copy of the input data, manipulates the copy, and returns the transformed copy as output. This differs from an “object-oriented” paradigm where functions have the ability to implicitly rewrite or change the state of the original data. It is easier to reason about a function that actually returns an object as output than one that changes the input object as a “side effect.” Design for humans. Designing a package for humans largely comes down to using consistent, explicit, and descriptive naming schemes for objects and functions. Conceptualizing the cartridge case comparison procedure as a pipeline makes it easier to understand. We go one step further by actually implementing the procedure as a sequence of algorithms that are programatically connected together in the R statistical programming language . In particular, we utilize the pipe operator available from the magrittr R package . The pipe operator allows the user to think intuitively in terms of verbs applied to the data. Table ?? illustrates two pipelines that utilize the pipe operator. The left-hand example shows how an R data frame is manipulated by piping it between functions from the dplyr package. Functions like group_by, summarize, and filter are simple building blocks strung together to create complicated workflows. The right-hand example similarly illustrates a cartridge case object passing through a comparison pipeline. While the full comparison procedure is complex, the modularization to the preProcess_, comparison_, and decision_ steps, which can further be broken-down into simpler functions, renders the process more understandable and flexible for the user. Adherence to tidy principles makes it easier to engage with and understand the overall data analysis pipeline. In our application it also enables experimentation by making it easy to change one step of the pipeline and measure the downstream effects . Each step of the cartridge case comparison pipeline requires the user to define parameters. These can range from minor to substantial, such as choosing the standard deviation used in a Gaussian filter to choosing the algorithm used to calculate a similarity score. So far, no consensus exists for the “best” parameter settings. A large amount of experimentation is yet required to establish these parameters. A tidy implementation of the cartridge case comparison pipeline allows more people to engage in the validation and improvement of the procedure. Figure 1.22, Figure 1.23, Figure 1.24, and Figure 1.25 illustrate how various forensic comparison algorithms use a modularized structure to conceptualize their pre-processing procedures. In each figure, a sequence of modular procedures are applied to a piece of evidence. Figure 1.22 shows morphological and image processing procedures applied to a 2D image of a cartridge case to remove the firing pin region . Figure 1.22: A pre-processing procedure applied to a 2D image of a cartridge case to identify the firing pin impression. The procedure results in a 2D image of a cartridge case without the firing pin impression region. Figure 1.23 shows the procedure by which a 2D “signature” of a bullet scan is extracted from a 3D topographical scan . Figure 1.23: A pre-processing procedure for extracting 2D bullet ``signatures” from a 3D topographic bullet scan. The procedure results in an ordered sequence of values representing the local variations in the surface of the bullet. Figure 1.24 shows how an image of the written word “csafe” is processed using the handwriter R package to break the word into individual graphemes that can be further processed . Figure 1.24: A pre-processing procedure applied to an image of the handwritten word “csafe.” The procedure results in a skeletonized version of the word that has been separated into graphemes as represented by orange nodes. Finally, Figure 1.25 shows a 3D topographical cartridge case scan undergoing various procedures to isolate and highlight the breech face impressions. These procedures are discussed in greater detail in Chapter 2. Figure 1.25: A cartridge case undergoing various pre-processing steps. The procedure results in a cartridge case scan in which the breech face impressions have been segmented and highlighted. By breaking the broader pre-processing step into modularized pieces, we can devise other arrangements of these pre-processing procedures that may improve the segmenting or emphasizing of the region of interest. The modularity of the pipeline makes it easier to understand what the algorithm is doing “under the hood.” A genuine modular implementation enables others to experiment with alternative versions of the pipeline, thus accelerating discovery and improvement. "],["a-study-in-reproducibility-the-congruent-matching-cells-algorithm-and-cmcr-package.html", "2 A Study in Reproducibility: The Congruent Matching Cells Algorithm and cmcR package Abstract 2.1 Introduction 2.2 The CMC pipeline 2.3 Discussion 2.4 Conclusion 2.5 Acknowledgement 2.6 Computational details", " 2 A Study in Reproducibility: The Congruent Matching Cells Algorithm and cmcR package Abstract Scientific research is driven by our ability to use methods, procedures, and materials from previous studies and further research by adding to it. As the need for computationally-intensive methods to analyze large amounts of data grows, the criteria needed to achieve reproducibility, specifically computational reproducibility, have become more sophisticated. In general, prosaic descriptions of algorithms are not detailed or precise enough to ensure complete reproducibility of a method. Results may be sensitive to conditions not commonly specified in written-word descriptions such as implicit parameter settings or the programming language used. To achieve true computational reproducibility, it is necessary to provide all intermediate data and code used to produce published results. In this paper, we consider a class of algorithms developed to perform firearm evidence identification on cartridge case evidence known as the Congruent Matching Cells (CMC) methods. To date, these algorithms have been published as textual descriptions only. We introduce the first open-source implementation of the Congruent Matching Cells methods in the R package cmcR. We have structured the cmcR package as a set of sequential, modularized functions intended to ease the process of parameter experimentation. We use cmcR and a novel variance ratio statistic to explore the CMC methodology and demonstrate how to fill in the gaps when provided with computationally ambiguous descriptions of algorithms. 2.1 Introduction Forensic examinations are intended to provide an objective assessment of the probative value of a piece of evidence. Typically, this assessment of probative value is performed by a forensic examiner who visually inspects the evidence to determine whether it matches evidence found on a suspect. The process by which an examiner arrives at their evidentiary conclusion is largely opaque and has been criticized (President’s Council of Advisors on Sci. &amp; Tech. 2016) because its subjectivity does not allow for an estimation of error rates. In response, National Research Council (2009) pushed to augment subjective decisions made by forensic examiners with automatic algorithms that objectively assess evidence and can be explained during court testimony. In addition to the objectivity of these algorithms, there is an additional benefit: we expect that an algorithm with the same random seed run on the same data multiple times will produce the same answer; that is, that the results are repeatable. This is extremely beneficial because it allows the prosecution and defense to come to the same conclusion given objective evidence or data. 2.1.1 Repeatability and reproducibility Repeatability in forensic labs is enforced primarily using standard operating procedures (SOPs), which specify the steps taken for any given evaluation, along with the concentrations of any chemicals used, the range of acceptable machine settings, and any calibration procedures required to be completed before the evidence is evaluated. When labs use computational procedures, this SOP is augmented with specific algorithms, which are themselves SOPs intended for use by man and machine. Algorithms are generally described on two levels: we need both the conceptual description (intended for the human using the algorithm) and the procedural definition (which provides the computer hardware with a precise set of instructions). For scientific and forensic repeatability and reproducibility, it is essential to have both pieces: the algorithm description is critical for establishing human understanding and justifying the method’s use in court, but no less important is the computer code which provides the higher degree of precision necessary to ensure the results obtained are similar no matter who evaluates the evidence. As with SOPs in lab settings, the code parameters function like specific chemical concentrations; without those details, the SOP would be incomplete and the results produced would be too variable to be accepted in court. The National Academy of Sciences, Engineering, and Medicine (2019) defines reproducibility as “obtaining consistent computational results using the same input data, computational steps, methods, code, and conditions of analysis.” This form of reproducibility requires that the input data, code, method, and computational environment are all described and made available to the community. In many situations, this level of reproducibility is not provided – not just in forensics but in many other applied disciplines. In forensics in particular, it is easier to list the exceptions: reproducible algorithms have been proposed in sub-disciplines including DNA (Tvedebrink, Andersen, and Curran 2020; Goor, Hoffman, and Riley 2020; Tyner et al. 2019), glass (Curran, Champod, and Buckleton 2000; Park and Tyner 2019), handwriting (Crawford 2020), shoe prints (Park and Carriquiry 2020), and ballistic evidence (Hare, Hofmann, and Carriquiry 2017; Tai and Eddy 2018). We find it useful to instead consider a more inclusive hierarchy of reproducibility. Algorithms at higher tiers of the hierarchy are more easily reproducible in the sense that fewer resources are required to (re)-implement the algorithm. Definition 1 Hierarchy of Reproducibility Conceptual description The algorithm is described and demonstrated in a scientific publication. Pseudocode The algorithm is described at a high level of detail with pseudocode implementation provided, and results are demonstrated in a scientific publication. Reproducible data The algorithm is described and demonstrated in a scientific publication, and input data are available in supplementary material. Comparable results The algorithm is described and demonstrated in a scientific publication, and input data and numerical results are provided in supplementary material. Full reproducibility The algorithm is described and demonstrated in a scientific publication, and the input data, source code, parameter settings, and numerical results are provided in supplementary material. To aid in comprehension of an algorithm, it is useful to supplement conceptual descriptions with pseudocode. However, a conceptual description and pseudocode alone do not contain sufficient detail (e.g., parameter settings) to ensure computational reproducibility. Implementing algorithms based on conceptual descriptions or pseudocode requires enumerating and testing possible parameter choices which, depending on their complexity, can be a lengthy and expensive process. In contrast, implementing fully reproducible algorithms requires only as much time as it takes to emulate the original development environment. Commonly identified reasons for unreproducible results include (1) ambiguity in how procedures were implemented, (2) missing or incomplete data, and (3) missing or incomplete computer code to replicate all statistical analyses (Leek and Jager 2017). In particular, for statistical algorithms which depend on input data, we find that full reproducibility depends on the provision of both original data and any manual pre-processing applied to said data, as this manual process is not reproducible by itself. In combination with the code, the algorithm description, and the numerical results presented in the paper, it should be possible to fully reproduce the results of a paper. In this paper, we demonstrate the importance of higher levels of reproducibility by examining the Congruent Matching Cells (CMC) algorithm for cartridge case comparisons and developing an open-source, fully reproducible version for general use in the forensics community. 2.1.2 The Congruent Matching Cells algorithm A cartridge case is the portion of firearm ammunition that encases a projectile (e.g., bullet, shots, or slug) along with the explosive used to propel the projectile through the firearm. When a firearm is discharged, the projectile is propelled down the barrel of the firearm, while the cartridge case is forced towards the back of the barrel. It strikes the back wall, known as the breech face, of the barrel with considerable force, thereby imprinting any markings on the breech face onto the cartridge case and creating the so-called breech face impressions. These markings are used in forensic examinations to determine whether two cartridge cases have been fired by the same firearm. During a forensic examination, two pieces of ballistic evidence are placed under a comparison microscope. Comparison microscopes allow for a side-by-side comparison of two objects within the same viewfinder, as seen in Figure 2.1. A pair of breech face images is aligned along the thin black line in the middle of the images. The degree to which these breech face markings can be aligned is used to determine whether the two cartridge cases came from the same source; i.e., were fired from the same firearm. These breech face impressions are considered analogous to a firearm’s “fingerprint” left on a cartridge case (Thompson 2017). Figure 2.1: A cartridge case pair with visible breech face impressions under a microscope. A thin line can be seen separating the two views. The degree to which the markings coincide is used to conclude whether the pair comes from the same source. The Congruent Matching Cells (CMC) pipeline is a collection of algorithms to process and compare cartridge case evidence (Song 2013). Since its introduction, the pipeline and its extensions (Tong, Song, and Chu 2015; Chen et al. 2017; Song et al. 2018) have shown promise in being able to differentiate between matching and non-matching cartridge cases. However, so far the CMC pipelines have only been introduced in the form of conceptual descriptions. Further, the cartridge case scans used to validate the pipelines are only available in their raw, unprocessed forms on the NIST Ballistics Toolmark Research Database (Zheng, Soons, and Thompson 2016). While it is clear that the creators of the CMC pipeline have a working implementation, the wider forensic science community only has access to conceptual descriptions of the pipeline and summary statistics describing its performance. In our hierarchy of reproducibility, this puts the CMC algorithm somewhere between the conceptual description and reproducible data stage: the steps are described but no code is available, and the raw data are available but manual pre-processing steps make this raw data insufficient to replicate the pipeline even with newly written code. The development of the CMC algorithm seems to be representative of how many forensic algorithms are developed: after an algorithm is introduced, researchers build upon the foundation laid by the original algorithm in subsequent papers. These changes are often incremental in nature and reflect a growing understanding of the algorithm’s behavior. While this cycle of scientific progress certainly is not unique to forensic algorithms, given the gravity of the application it is imperative that these incremental improvements not be unnecessarily delayed. As such, we believe that the forensic community at-large would benefit greatly by establishing an open-source foundation for their algorithms upon which additional improvements can be developed. Using open-source algorithms are cheaper to use than writing one’s own code, enables the process of peer review by providing an accessible benchmark, and helps other research groups or companies stay on the leading edge of technology development (The Linux Foundation 2017). Here, we describe the process of implementing the CMC pipeline for the comparison of marks on spent cartridge cases, using the descriptions from two published papers, Song et al. (2014) and Tong, Song, and Chu (2015). Our R package, cmcR, provides an open-source implementation of the CMC pipeline. We use cmcR to illustrate how ambiguities in the textual description of an algorithm can lead to highly divergent results. In particular, our implementation highlights an extreme sensitivity to processing and parameter decisions that has not been discussed previously. Additionally, we argue that our implementation can be used as a template for future implementations of forensic pattern-matching algorithms to not only ensure transparency and auditability, but also to facilitate incremental improvements in forensic algorithms. In the remainder of this paper, we describe a general, reproducible, and open-source CMC pipeline which encompasses those discussed in Song (2013), Song et al. (2014), and Tong, Song, and Chu (2015). Song (2013) lays out the conceptual framework for the original CMC pipeline later implemented in Song et al. (2014) and Tong et al. (2014). An improvement of the pipeline presented in Tong, Song, and Chu (2015) and used in subsequent papers is referred to as the “High CMC” method (Chen et al. 2017). However, it should be noted that what the authors refer to as the original and High CMC decision rules are variations of one step of a larger CMC pipeline. The cmcR package contains implementations designed for use with 3D topographical scans of the original decision rule described in Song (2013) and Song et al. (2014) and the High CMC decision rule described in Tong, Song, and Chu (2015). The source code to the full cmcR package is accessible at https://github.com/CSAFE-ISU/cmcR. 2.2 The CMC pipeline In this section, we examine the process of implementing the CMC pipeline for automatic comparisons of 3D cartridge case scans. At each step, we will discuss how we filled in the gaps of the original description during the creation of cmcR. All of the CMC pipelines can be broken down into three broad stages: (1) pre-processing, (2) cell-based similarity feature extraction, and (3) application of a decision rule as illustrated in @(fig:overview-flow). In the following sections we break each of these stages further into a set of modular steps. One advantage of modularizing these algorithms is that we can implement an algorithm as a set of sequential procedures. This allows us to test new variations against the old implementation in a coherent, unified framework. Figure 2.2: The stages of CMC pipelines. In the pre-processing stage, each scan is prepared for analysis, removing extraneous information and noise. Then, each scan is broken up into cells, which are numerically compared to cells in the other scan to determine an optimal alignment. Finally, each of the scores arising from the cells in the second stage are compared to a reference distribution to determine whether the scans originate from the same source or from different sources. The primary difference between the two pipelines presented here, using the original and High CMC decision rules, lies in how the decision rules are utilized to separate matching vs. non-matching cartridge case pairs. In addition, there are also several small differences in the parameters used in the pre-processing and comparison procedures. 2.2.1 Initial data Digital microscopy is capable of precision measurements of surface topology at high resolutions. Using a 3D microscope, we can obtain scans of breech face impressions at the micron level (\\(1 \\mu m = 10^{-3} mm = 10^{-6} m\\)). These 3D topological scans are used as input to automated comparison algorithms, such as the CMC pipeline originally proposed in Song (2013). We will use the same data set referenced in Song et al. (2014) and Tong, Song, and Chu (2015) to illustrate usage of the cmcR package. These 3D scans of cartridge cases are available from the NIST Ballistics Toolmark Research Database (Zheng, Soons, and Thompson 2016). The strings defined below refer to three cartridge case scans available on the NBTRD from Fadul et al. (2011) and will be used throughout the remainder of this paper. library(cmcR) nbtrd_url &lt;- &quot;https://tsapps.nist.gov/NRBTD/Studies/CartridgeMeasurement&quot; x3p_ids &lt;- c(&quot;DownloadMeasurement/2d9cc51f-6f66-40a0-973a-a9292dbee36d&quot;, &quot;DownloadMeasurement/cb296c98-39f5-46eb-abff-320a2f5568e8&quot;, &quot;DownloadMeasurement/8ae0b86d-210a-41fd-ad75-8212f9522f96&quot;) file_names &lt;- c(&quot;fadul1-1.x3p&quot;,&quot;fadul1-2.x3p&quot;,&quot;fadul2-1.x3p&quot;) purrr::walk2(.x = x3p_ids, .y = file_names, .f = function(x3p_id,file_name){ download.file(url = file.path(nbtrd_url, x3p_id), destfile = paste0(&quot;data/&quot;,file_name),mode = &quot;wb&quot;) }) Cartridge case scans are commonly stored in the ISO standard x3p file format (“Geometrical product specifications (GPS) — Surface texture: Areal — Part 72: XML file format x3p” 2017). x3p is a container format which consists of a single surface matrix representing the height value of the breech face surface and metadata concerning the parameters under which the scan was taken (size, resolution, creator, microscope, microscopy software versions, etc.). The x3ptools package provides functionality to work with the format in R (Hofmann et al. 2020). Figure 2.3 shows the surface matrices of a known match (KM) pair of cartridge cases from a study by Fadul et al. (2011). In this study, a total of 40 cartridge cases were scanned with a lateral resolution of 6.25 microns (micrometers) per pixel. The surface matrices are approximately \\(1200 \\times 1200\\) pixels in size corresponding to an area of about \\(3.8 \\times 3.8\\) mm\\(^2\\). Figure 2.3: Unprocessed surface matrices of the known-match Fadul 1-1 and Fadul 1-2 Fadul et al. \\(2011\\). The observations in the corners of these surface matrices are artifacts of the staging area in which these scans were taken. The holes on the interior of the primer surfaces are caused by the firing pin striking the primer during the firing process. The region of the primer around this hole does not come into uniform contact with the breech face of the firearm. Only certain regions of a cartridge case contain identifying breech face impression markings. Song (2013) defines “valid correlation regions” as regions where “the individual characteristics of the ballistics signature are found that can be used effectively for ballistics identification.” Prior to applying the CMC comparison procedure, cartridge scans must undergo some pre-processing to isolate the valid correlation regions. 2.2.2 Pre-processing procedures During the pre-processing stage, we apply sequential steps to prepare each cartridge case for analysis. The goal of this process is to remove the edges and center of the scan which did not come into contact with the breech face, as well as any artifacts of the scan and microscope staging which do not accurately represent the breech face surface. The various iterations of the CMC algorithm describe different variations of these steps. A summary of these steps is shown in Figure 2.4. Figure 2.4: Overview of the set of pre-processing steps used in the CMC algorithms. Where a procedure step is not discussed or explicitly not applied in the paper, the path traverses empty space. Translating the pre-processing steps in Figure 2.4 into an implementation requires the implementer to decide between potentially many implicit parameter choices. For example, Table 2.1 compares the pre-processing procedures as described in Song et al. (2014) to considerations that need to be made when implementing the procedures. Depending on one’s interpretation of the description, there are many possible implementations that satisfy the described procedure - in contrast, there was only one implementation that led to the original results. While not explicitly mentioned in Song et al. (2014), Song et al. (2018) indicates that the “trimming” of the unwanted regions of the scan is performed manually. It is difficult to replicate manual steps as part of a reproducible pipeline; the best solution is for the authors to provide intermediate data after the manual steps have been completed. Table 2.1: Description of pre-processing procedures from Song et al. \\(2014\\) vs. considerations that need to be made when implementing these procedures. Each of these considerations requires the implementer to decide between potentially many choices. Description from Song et al. (2014) Implementation Considerations “Trim off the inside firing pin surface and other areas outside the breech face mark, so that only breech face impression data remain for correlation.” Removal of firing pin hole and primer exteriorRemoval of global trendRemoval of primer roll-off “Identify and remove dropouts or outliers.” Definition of outliersWhat “removal” of dropouts or outliers means “Apply a band-pass Gaussian regression filter with 40 \\(\\mu\\)m short cut-off length and 400 \\(\\mu\\)m long cut-off length to remove low frequency components, including surface curvature, form error, waviness and high frequency components which mainly arise from the instrument noise.” Wavelength cut-off parametersSpecific implementation of the filter The pre-processing procedures are implemented via modularized functions of the form preProcess_*. Modularizing the steps of the pre-processing procedures makes the overall process easier to understand and allows for experimentation. Figure 2.5 shows an overview of the pre-processing framework for the Fadul 1-1 breech face from reading the scan (left) to an analysis-ready region (right). For each scan in Figure 2.5, eleven height value percentiles: the Minimum (0th), 1st, 2.5th, 10th, 25th, Median (50th), 75th, 90th, 97.5th, 99th, and Maximum (100th) are mapped to a purple-to-orange color gradient. This mapping is chosen to highlight the extreme values in each scan. Figure 2.5: Illustration of the sequential application of pre-processing steps implemented in cmcR. We map the cartridge case surface height values to a divergent purple-white-orange color scale to emphasize deviations from the median height value (represented here as 0 micrometers). At each stage, the variability in height across the scan decreases as we emphasize the regions containing breech face impressions. We demonstrate usage of the preProcess_* functions on the Fadul 1-1 scan. Each code chunk is followed up with an explanation of the functions used. # Step (1) fadul1.1 &lt;- x3ptools::x3p_read(&quot;data/fadul1-1.x3p&quot;) We begin with a 3D scan. Typically, we downsample scans to about 25% of their size by only retaining every other row and column in the surface matrix. The breech faces in Fadul et al. (2011) were initially scanned at a resolution of 3.125 \\(\\mu\\)m per pixel. Downsampling reduces the resolution to 6.25 \\(\\mu\\)m per pixel. Step (1) in Figure 2.5 shows an unprocessed breech face scan. # Step (2) fadul1.1_cropped &lt;- fadul1.1 %&gt;% cmcR::preProcess_crop(region = &quot;exterior&quot;) %&gt;% cmcR::preProcess_crop(region = &quot;interior&quot;) We then use a labeling algorithm to identify three major regions of the scan: the exterior of the cartridge case primer, the breech face impression region of interest, and the firing pin impression region in the center of the scan (Hesselink, Meijster, and Bron 2001; Barthelme 2019). We remove observations outside of the breech face impression region (i.e., replaced with NA). The resulting breech face scan, like the one shown in step (2) of Figure 2.5, is reproducible assuming the same parameters are used. The preProcess_crop function removes the exterior and firing pin impression region on the interior based on the region argument. # Step (3) fadul1.1_deTrended &lt;- fadul1.1_cropped %&gt;% preProcess_removeTrend(statistic = &quot;quantile&quot;, tau = .5, method = &quot;fn&quot;) In step (3), we remove the southwest-to-northeast trend observable in steps (1) and (2) of Figure 2.5 by subtracting the estimated conditional median height value. The result of the preProcess_removeTrend function the median-leveled breech face scan in step (3) of Figure 2.5. # Step (4) fadul1.1_processed &lt;- fadul1.1_deTrended %&gt;% preProcess_gaussFilter(filtertype = &quot;bp&quot;, wavelength = c(16,500)) %&gt;% x3ptools::x3p_sample(m = 2) Finally, we apply a band-pass Gaussian filter to the surface values to attenuate noise and unwanted large-scale structure. Step (4) of Figure 2.5 shows the effect of the preProcess_gaussFilter function. There is currently no determination or removal of outliers in the cmcR package’s pre-processing procedures. Instead, we rely on the low-pass portion of the Gaussian filter to reduce the effects of any high-frequency noise. Figure 2.6 displays the processed Fadul 1-1 and Fadul 1-2 scans; the second matrix is processed using the same parameters. Next, similarity features are extracted from a processed cartridge case pair in the cell-based comparison procedure. Figure 2.6: Fadul 1-1 and Fadul 1-2 after pre-processing. Similar striated markings are now easier to visually identify on both surfaces. It is now clearer that one of the scans needs to be rotated to align better with the other. 2.2.3 “Correlation cell” comparison procedure As described in Song (2013), breech face markings are not uniformly impressed upon a cartridge case during the firing process. As such, only certain sections of the cartridge case are used in a comparison. In the CMC pipeline as proposed by Song (2013) two scans are compared by partitioning one breech face scan into a grid of so-called “correlation cells”. These cells are compared individually to their best-matching counterpart on the other scan. If a large proportion of these correlation cells are highly similar to their counterparts on the other breech face scan, this is considered as evidence that the markings on the two cartridge cases were made by the same source. The number of highly similar cells is defined as the CMC count \\(C\\) (Song 2013) of the breech-face comparison. The CMC count is considered to be a more robust measure of similarity than the correlation calculated between two full scans. Figure 2.7: Illustration of comparing a cell in the reference cartridge case scan (left) to a larger region in a questioned cartridge case scan (right). Every one of the cells in the reference cartridge case is similarly paired with a region in the questioned cartridge case. To determine the rotation at which the two cartridge cases align, the cell-region pairs are compared for various rotations of the questioned cartridge case. Figure 2.7 illustrates the cell-based comparison procedure between two cartridge case scans. The scan on the left serves as the reference; it is divided into a grid of \\(8 \\times 8\\) cells. Figure 2.8: Each CMC implementation uses a slightly different procedure to obtain a similarity score between two cartridge cases. Steps which are implemented with additional user-specified parameters are shaded purple; steps which are described but without sufficient detail are shaded grey. Figure 2.8 shows the steps of the correlation cell comparison process in each of the papers as well as the cmcR implementation. Each cell is paired with an associated larger region in the other scan. The absolute location of each cell and region in their respective surface matrices remain constant. However, the scan on the right is rotated to determine the rotation at which the two scans are the most “similar,” as quantified by the cross-correlation function (CCF). For real-valued matrices \\(A\\) and \\(B\\) of dimension \\(M \\times N\\) and \\(P \\times Q\\), respectively, the cross-correlation function, denoted \\((A \\star B)\\) is defined as \\[ (A \\star B)[m,n] = \\sum_{i=1}^M \\sum_{j=1}^N A[i,j] B[(i + m), (j + n)], \\] where \\(1 \\leq m \\leq M + P - 1\\) and \\(1 \\leq n \\leq N + Q - 1\\). By this definition, the \\([m,n]\\)th element of the resulting \\(M + P - 1 \\times N + Q - 1\\) CCF matrix quantifies the similarity between matrices \\(A\\) and \\(B\\) for a translation of matrix \\(B\\) by \\(m\\) pixels horizontally and \\(n\\) pixel vertically. The index at which the CCF attains a maximum represents the optimal translation needed to align \\(B\\) with \\(A\\). The CCF as defined need not be bounded between \\(-1\\) and \\(1\\). However, it is common to normalize the CCF for interpretability, and this is the convention adopted in the cmcR package. Prior to calculating the CCF, the matrices \\(A\\) and \\(B\\) are standardized through subtraction of their respective means and division by their respective standard deviations. This is referred to as the Areal Cross-Correlation Function (ACCF) in some CMC papers (Ott, Thompson, and Song 2017). A direct calculation of the CCF for breech face scans based on the definition above is prohibitively slow. While computationally feasible alternatives exist, Song (2013) and other CMC papers do not specify the algorithm used to calculate the CCF. Published descriptions of the CMC algorithm do not detail how the CCF is calculated. In image processing, it is common to use an implementation based on the Fast Fourier Transform (Brown 1992). This implementation leverages the Cross-Correlation Theorem, which states that for matrices \\(A\\) and \\(B\\), the CCF can be expressed in terms of a frequency-domain pointwise product: \\[ (A \\star B )[m,n]= \\mathcal{F}^{-1}\\left(\\overline{\\mathcal{F}(A)} \\odot \\mathcal{F}(B)\\right)[m,n], \\] where \\(\\mathcal{F}\\) and \\(\\mathcal{F}^{-1}\\) denote the discrete Fourier and inverse discrete Fourier transforms, respectively, and \\(\\overline{\\mathcal{F}(A)}\\) denotes the complex conjugate (Brigham 1988). Because the product on the right-hand side is calculated pointwise, we trade the moving sum computations from the definition of the CCF for two forward Fourier transformations, a pointwise product, and an inverse Fourier transformation. The Fast Fourier Transform (FFT) algorithm can be used to reduce the computational load considerably. Our implementation of this FFT-based CCF calculation is adapted from the cartridges3D package (Tai 2021). No computational shortcut comes without some trade-offs, though, and this FFT-based CCF calculation is no different. The FFT does not tolerate missing values, and breech faces are not continuous surfaces – all of the white regions in Figure 2.7 correspond to missing values. While it is unclear how the CCF is implemented in the CMC papers, the cmcR package adopts the following conventions: Only cells with a minimum proportion of non-missing pixels are assessed. This minimum threshold differs across CMC papers (15% in Chen et al. (2017) vs. 10% in Song et al. (2018), as shown in Figure 2.8), and is referenced but not specified in several other papers (Tong et al. 2014; Song et al. 2014; Chu, Tong, and Song 2013). The comparison_calcPropMissing function computes the proportion of a matrix that is missing (NA-valued). Missing values are replaced with the overall mean value when the FFT-based CCF is computed (using function comparison_replaceMissing). The optimal translation is determined using the FFT-based CCF (using comparison_fft_ccf). Based on the optimal translation determined from the FFT-based CCF, we compute the pairwise complete CCF directly, avoiding any distortion of the CCF computation based on compensation for missing values (using function comparison_cor). All of the steps dealing with cell-based comparisons are implemented as functions of the form comparison_*. Similar to the preProcess_* functions, the comparison_* functions can be chained together through a sequence of pipes. Below, we use the comparison_allTogether function to perform the entire cell-based comparison procedure in one call. The comparison procedure is performed twice: once with Fadul 1-1 considered the “reference” scan divided into cells that are compared to the “target” scan Fadul 1-2 and again with the roles reversed. # Fill in most of the arguments first comp_w_pars &lt;- purrr::partial(.f = comparison_allTogether, numCells = c(8,8), maxMissingProp = .85) # Then, map the remaining values to theta kmComparisonFeatures &lt;- purrr::map_dfr( seq(-30,30,by = 3), ~comp_w_pars(reference = fadul1.1, target = fadul1.2, theta = .)) kmComparisonFeatures_rev &lt;- purrr::map_dfr( seq(-30,30,by = 3), ~comp_w_pars(reference = fadul1.2, target = fadul1.1, theta = .)) The comparison_allTogether function consists of the following steps wrapped into a single convenience function: comparison_cellDivision: Divide the reference scan into cells comparison_getTargetRegions: Extract regions associated with each reference cell from the target scan comparison_calcPropMissing: Compute missing proportions and filter out cells with a proportion of missing values above the threshold. comparison_standardizeHeights: Standardize height values comparison_replaceMissing: Replace missing values comparison_fft_ccf: Compute CCF and estimated translations using FFT comparison_alignedTargetCell: Extract a matrix from the target scan corresponding to the region of the target scan to which the reference cell aligns cor: Calculate the pairwise-complete correlation between each cell pair The comparison_allTogether is called repeatedly while rotating the target scan by a set of rotation angles. When implementing the High CMC decision rule (Tong, Song, and Chu 2015), both combinations of reference and target scan are examined (e.g. A-B and B-A). Table 2.2 shows several rows of the data frame output of the comparison_allTogether function for the comparison of Fadul 1-1 vs. Fadul 1-2 considering Fadul 1-1 as the reference scan. Although we used a grid of \\(8 \\times 8\\) cells, there were only 26 cell-region pairs that contained a sufficient proportion of non-missing values (15% in this example). The features derived from the correlation cell procedure (CCF\\(_{max}\\), \\(\\Delta x\\), \\(\\Delta y\\), \\(\\theta\\)) are then used to measure the similarity between scans. Table 2.2: Example of output from correlation cell comparison procedure between Fadul 1-1 and Fadul 1-2 rotated by -24 degrees. Due to the large proportion of missing values that are replaced to compute the FFT-based correlation, the pairwise-complete correlation is most often greater than the FFT-based correlation. Cell Index Pairwise-comp. corr. FFT-based corr. \\(\\Delta\\)x \\(\\Delta\\)y \\(\\theta\\) 2, 7 0.432 0.228 -14 -33 -24 2, 8 0.464 0.176 9 -44 -24 3, 1 0.841 0.478 -7 15 -24 3, 8 0.699 0.277 -7 5 -24 4, 1 0.850 0.375 -4 11 -24 2.2.4 Decision rule For each cell on the reference scan, we calculate the translation \\((\\Delta x, \\Delta y)\\) and cross-correlation across rotations by a set of angles \\(\\theta\\) of the target scan. The task is to determine whether multiple cells come to a “consensus” on a particular translation and rotation. If such a consensus is reached, then there is evidence that a true aligning translation and rotation exists and the cartridge cases match. The CMC decision rules principally differ in how they identify consensus among the \\(\\Delta x, \\Delta y, \\theta\\) values. Here, we describe the two pipelines implemented in the cmcR package: using the original decision rule described in Song et al. (2014) and the High CMC decision rule proposed in Tong, Song, and Chu (2015). 2.2.4.1 The Original CMC decision rule This section briefly describes the decision rule used in the first CMC paper (Song 2013). For a thorough explanation of the procedure, refer to the CMC Decision Rule Description vignette of the cmcR package. Let \\(x_i, y_i, \\theta_i\\) denote the translation and rotation parameters which produce the highest CCF for the alignment of cell-region pair \\(i\\), \\(i = 1,...,n\\) where \\(n\\) is the total number of cell-region pairs containing a sufficient proportion of non-missing values. Song (2013) propose the median as a consensus \\((x_{\\text{ref}}, y_{\\text{ref}}, \\theta_{\\text{ref}})\\) across the cell-region pairs. Then, the distance between each \\((x_i, y_i, \\theta_i)\\) and \\((x_{\\text{ref}}, y_{\\text{ref}}, \\theta_{\\text{ref}})\\) is compared to thresholds \\(T_{x}, T_{y}, T_\\theta, T_{\\text{CCF}}\\). A cell-region pair \\(i\\) is declared a “match” if all of the following conditions hold: \\[\\begin{eqnarray} |x_i - x_{\\text{ref}}| &amp;\\leq&amp; T_{x}, \\\\ \\nonumber |y_i - y_{\\text{ref}}| &amp;\\leq&amp; T_{y}, \\\\ \\nonumber |\\theta_i - \\theta_{\\text{ref}}| &amp;\\leq&amp; T_{\\theta}, \\\\ \\nonumber \\text{CCF}_{\\max,i} &amp;\\geq&amp; T_{\\text{CCF}}. \\tag{2.1} \\end{eqnarray}\\] The number of matching cell-region pairs, the “CMC count,” is used as a measure of similarity between the two cartridge cases. Song et al. (2014) indicate that the thresholds \\(T_{x}, T_{y}, T_\\theta, T_{\\text{CCF}}\\) need to be determined experimentally. Table 2.3 summarizes the thresholds used in various CMC papers. Table 2.3: Different thresholds for translation, rotation, and CCF\\(_{\\max}\\) are used across different papers. The range in CCF\\(_{\\max}\\) is particularly notable. Paper Translation \\(T_x, T_y\\) (in pixels) Rotation \\(\\theta\\) (in degrees) \\(CCF_{\\max}\\) Song et al. (2014) 20 6 0.60 Tong et al. (2014) 30 3 0.25 Tong et al. (2015) 15 3 0.55 Chen et al. (2017) 20 3 0.40 Song et al. (2018) 20 6 0.50 Unlike the original CMC pipeline, the High CMC decision rule considers multiple rotations for each cell-region pair. 2.2.4.2 The High CMC decision rule For the High CMC decision rule, two scans are compared in both directions - i.e., each scan takes on the role of the reference scan that is partitioned into a grid of cells. Tong, Song, and Chu (2015) claim that some matching cell-region pairs “may be mistakenly excluded from the CMC count” under the original decision rule because they attain the largest CCF at a rotation outside the range allowed by \\(T_\\theta\\) “by chance.” Tong, Song, and Chu (2015) introduce consensus values across all cell-region pairs for each rotation angle \\(\\theta\\) and calculate a \\(\\theta\\)-dependent CMC count as the sum of matches observed. Under the High CMC rule, a cell-region pair \\(i\\) is defined as a match conditional on a particular rotation \\(\\theta\\) if it satisfies the following three conditions: \\[\\begin{eqnarray} |x_{i,\\theta} - x_{ref,\\theta}| &amp;\\leq&amp; T_x \\\\ \\nonumber |y_{i,\\theta} - y_{ref,\\theta}| &amp;\\leq&amp; T_y \\\\ \\nonumber \\text{CCF}_{i,\\theta} &amp;\\geq&amp; T_{\\text{CCF}}. \\tag{2.2} \\end{eqnarray}\\] The \\(\\theta\\)-dependent CMC count, CMC\\(_\\theta\\), is defined as the sum of matching cell-region pairs. Tong, Song, and Chu (2015) assert that for a truly matching cartridge case pair, the relationship between \\(\\theta\\) and CMC\\(_\\theta\\) should exhibit a “prominent peak” near the true rotation value. That is, CMC\\(_{\\theta}\\) should be largest when the scans are close to being correctly aligned. Further, non-matching pairs should exhibit a “relatively flat and random […] pattern” across the CMC\\(_{\\theta}\\) values. To determine whether a “prominent peak” exists in the relationship between \\(\\theta\\) and CMC\\(_\\theta\\), Tong, Song, and Chu (2015) consider an interval of rotation angles with large associated CMC\\(_\\theta\\) values. Let \\(CMC_{\\text{max}} = \\max_{\\theta} CMC_{\\theta}\\) be the maximum CMC\\(_\\theta\\) count across all rotation angles. For \\(\\tau &gt; 0\\), define \\(S(\\tau) = \\{\\theta : CMC_\\theta &gt; (CMC_{\\max} - \\tau)\\}\\) as the set of rotations with “large” CMC\\(_\\theta\\) values. Tong, Song, and Chu (2015) consider the “angular range” as \\(R(\\tau) = |\\max_{\\theta} S(\\tau) - \\min_\\theta S(\\tau)|\\). If \\(R(\\tau)\\) is small, then there is evidence that many cells agree on a single rotation and that the scans match. To arrive at a CMC count similarity score, Tong, Song, and Chu (2015) suggest a value for \\(\\tau\\) of 1 and determine: If the angular range of the “high CMCs” is within the range \\(T_\\theta\\), identify the CMCs for each rotation angle in this range and combine them to give the number of CMCs for this comparison in place of the original CMC number. If the angular range is larger than \\(T_\\theta\\), we say that the cartridge case pair “fails” the High CMC criteria and the original CMC number is used. The High CMC decision rule returns a CMC count at least as large as the original decision rule. 2.2.4.3 Implementation of decision rules In this section, we implement the decision rules in cmcR for both the original and High CMC decision rules. For illustrative purposes, we consider a set of thresholds: \\(T_x = T_y = 20\\), \\(T_{\\theta} = 6\\), and \\(T_{\\text{CCF}} = 0.5\\). Decision rules in cmcR are implemented as functions of the form decision_*. In particular, the decision_CMC function applies both the original and High CMC decision rules depending on if the parameter \\(\\tau\\) is set. The code below demonstrates the use of decision_CMC on the features kmComparisonFeatures, extracted from the comparison of scans Fadul 1-1 vs. Fadul 1-2. Conversely, kmComparisonFeatures_rev contains the features from a comparison of Fadul 1-2 vs. Fadul 1-1. For comparison, we also compute the CMCs under both decision rules for the comparison between the non-match pair Fadul 1-1 and Fadul 2-1 (not shown to avoid redundancy). kmComparison_cmcs &lt;- kmComparisonFeatures %&gt;% mutate( originalMethodClassif = decision_CMC(cellIndex = cellIndex, x = x, y = y, theta = theta, corr = pairwiseCompCor, xThresh = 20, thetaThresh = 6, corrThresh = .5), highCMCClassif = decision_CMC(cellIndex = cellIndex, x = x, y = y, theta = theta, corr = pairwiseCompCor, xThresh = 20, thetaThresh = 6, corrThresh = .5, tau = 1)) We use the cmcPlot function to visualize congruent matching cells (CMCs) and non-congruent matching cells (non-CMCs). Figure 2.9 shows the CMCs and non-CMCs in blue and red, respectively, based on the original decision rule. The (red) non-CMC patches are shown in the position where the maximum CCF value in the target scan is attained. The top row shows 18 CMCs in blue and 8 non-CMCs in red when Fadul 1-1 is treated as the reference and Fadul 1-2 the target. The bottom row shows the 17 CMCs and 13 non-CMCs when the roles are reversed. There is no discussion in Song (2013) about combining the results from these two comparison directions, but Tong, Song, and Chu (2015) propose using the minimum of the two CMC counts (17 in this example). Figure 2.9: CMC results for the comparison between Fadul 1-1 and Fadul 1-2 using the original decision rule. The two plots in the top row show the 18 CMCs when Fadul 1-1 is treated as the “reference” cartridge case to which Fadul 1-2 (the “target”) is compared. The second row shows the 17 CMCs when the roles are reversed. Red cells indicate where cells not identified as congruent achieve the maximum pairwise-complete correlation across all rotations of the target scan. Similarly, CMCs and non-CMCs determined under the High CMC decision rule are shown in Figure 2.10. Treating Fadul 1-1 and Fadul 1-2 as the reference scan yields 20 and 18 CMCs, respectively. Combining the results as described above, the final High CMC count is 24. Figure 2.10: Applying the High CMC decision rule to the comparison of Fadul 1-1 and Fadul 1-2 results in 20 CMCs when Fadul 1-1 is treated as the reference (top) and 18 CMCs when Fadul 1-2 is treated as the reference (bottom). Although the individual comparisons do not yield considerably more CMCs than under the original CMC pipeline, Tong et al. (2015) indicate that the High CMCs from both comparisons are combined as the final High CMC count (each cell is counted at most once). Combining the results means that the High CMC decision rule tends to produce higher CMC counts than the original CMC pipeline. In this example, the combined High CMC count is 24 CMCs. In contrast, Figure 2.11 shows the CMC results for a comparison between Fadul 1-1 and a known non-match scan, Fadul 2-1, under the exact same processing conditions. Only two cells are classified as congruent matching cells under the original decision rule when Fadul 1-1 is the reference scan. No cells are classified as CMCs in the other direction. While not shown, this pair fails the High CMC criteria and thus was assigned 0 CMCs under the High CMC decision rule. Figure 2.11: Applying both decision rules to the comparison between the non-match pair Fadul 1-1 and Fadul 2-1 results in 2 CMCs under the original decision rule (shown above) and 0 CMCs under the High CMC decision rule (not shown). The seemingly random behavior of the red cells exemplifies the assumption that cells in a non-match comparison do not exhibit an observable pattern. Random chance should be the prevailing factor in classifying non-match cells as CMCs. 2.3 Discussion 2.3.1 Ambiguity in algorithmic descriptions During the implementation process we encountered ambiguous descriptions of the various CMC pipelines. We include the pre-processing and cell-based comparison procedures in the description of CMC methodology to emphasize how sensitive the final results are to decisions made in these first two steps. The pre-processing and cell-based comparison procedures are discussed only briefly, if at all, in Song et al. (2014), Tong et al. (2014), Tong, Song, and Chu (2015), or Chen et al. (2017). However, the results reported often indicate a sensitivity to these procedures. Ambiguities range from minor implicit parameter choices (e.g., the convergence criteria for the robust Gaussian regression filter (Brinkman and Bodschwinna 2003)) to procedures that are fundamental to feature calculation (e.g., how the cross-correlation is calculated). We bring up these ambiguities to demonstrate the difficulties that we faced when translating the conceptual description of the CMC pipeline into an actual pipeline. While many of these choices are unlikely to affect the results dramatically, we believe that any amount of variability that exists solely because of uncertainty in how the method was intended to be implemented is both unnecessary and dangerous in this application. The only solution to such ambiguity is to enumerate, implement, and pare-down the possible choices that could have been made to arrive to published results. Unsurprisingly, this process takes a considerable amount of time and resources that would be better spent furthering the state of the field. During the creation of the cmcR package, the process of re-implementing the comparison and decision steps of the pipeline was fairly straightforward. Emulating the pre-processing procedures used, on the other hand, took months of trial and error. Even after this effort, we still have no assurances that our implementation would match the results of the original implementation if applied to other data sets. In the next section, we describe the process of resolving these ambiguities in the CMC pipeline descriptions. In doing so, we abstract a set of principles by which pipelines and results can be rendered both computationally reproducible and more thoroughly understood. 2.3.2 CMC pattern matching pipeline As described in the initial data section, the set of cartridge case scans from Fadul et al. (2011) is commonly used to compare the performance of various classification methods (Song et al. 2014; Tong, Song, and Chu 2015; Chen et al. 2017). This set consists of 40 cartridge cases and 780 total comparisons: 63 known match comparisons and 717 known non-match comparisons. Scans of each breech face impression were taken with a Nanofocus Confocal Light Microscope at 10 fold magnification for a nominal lateral resolution of 3.125 microns per pixel and published to the NBTRD (Zheng, Soons, and Thompson 2016). We also use the Weller et al. (2012) data set of 95 cartridge cases for comparison. For the Weller et al. (2012) dataset, we manually isolated the breech face impression regions using the FiX3P software (accessible here: https://github.com/talenfisher/fix3p). We compare results from the cmcR package to published results using processed scans available through the Iowa State University DataShare repository (Zemmels, Hofmann, and Vanderplas 2022). Our goal is to show that results obtained from cmcR are similar, at least qualitatively, to previously published results. However, justification for any differences will ultimately involve educated guesses due to the closed-source nature of the original implementations. For each cartridge case pair, we calculate CMC counts under both the original and High CMC decision rules. In practice, we classify a cartridge case pair as “matching” if its CMC count surpasses some threshold; 6 CMCs being the generally accepted threshold in many papers (Tong, Song, and Chu 2015; Song et al. 2018; Song 2013). However, this threshold has been shown to not generalize well to all proposed methods and cartridge case data sets (Chen et al. 2017). We instead use an optimization criterion to select parameters. In doing so, we will demonstrate the sensitivity of the pipeline to parameter choice. Additionally, we introduce a set of principles designed to reduce the need for brute-force searches across parameter settings when re-implementing algorithms without accompanying code. Adherence to these principles yields not only computationally reproducible results, but also improves a reader’s understanding of a proposed pipeline. 2.3.3 Processing condition sensitivity Choosing threshold values \\(T_x, T_y, T_\\theta, T_{\\text{CCF}}\\) for translation, rotation, and maximum cross-correlation is crucial in declaring a particular cell-region pair “congruent.” However, many combinations of these thresholds yield perfect separation between the matching and non-matching CMC count distributions. Therefore, choosing parameters based on maximizing classification accuracy does not lead to an obvious, single set of parameters. We instead consider the ratio of between- and within-group variability to measure separation between match and non-match CMC counts. Let C\\(_{ij}\\) denote the CMC count assigned to the \\(j\\)th cartridge case pair, \\(j = 1,...,n_i\\) from the \\(i\\)th group, \\(i = 1,2\\) representing matches and non-matches, respectively. For each set of thresholds we calculate the Variance Ratio \\(r\\) as: \\[ r = r\\left(T_x, T_y, T_\\theta, T_{\\text{CCF}}\\right) = \\frac{\\sum_{i=1}^2 \\left(\\overline{C}_{i.} - \\overline{C}_{..}\\right)^2}{\\sum_{i=1}^2 \\frac{1}{n_i - 1}\\sum_{j=1}^{n_i} \\left(C_{ij} - \\overline{C}_{i.}\\right)^2}, \\] where \\(\\overline{C}_{i.}\\) denotes the within-group CMC count average and \\(\\overline{C}_{..}\\) denotes the grand CMC count average. Greater separation between and less variability within the match and non-match CMC count distributions yields larger \\(r\\) values. For example, Figure 2.12 shows results for the original decision rule and the High CMC decision rule for parameters \\(T_x = 20 = T_y\\) pixels, \\(T_{\\text{CCF}} = 0.5\\), and \\(T_{\\theta} = 6\\). Despite both decision rules resulting in separation between the matching and non-matching CMC count distributions, the High CMC decision rule yields greater separation as evidenced by the larger \\(r\\) value. Figure 2.12: CMC count relative frequencies under the original decision rule and the High CMC decision rule for \\(T_{\\Delta x} = 20 = T_{\\Delta y}\\) pixels, \\(T_{\\text{CCF}} = 0.5\\), and \\(T_{\\theta} = 6\\) degrees. An AUC \\(= 1\\) corresponds to perfect separation of the match and non-match CMC count distributions. We can see that, for this set of processing parameters, the High CMC decision rule yields higher CMC counts for known matches that the original decision rule while known non-matches have the same distribution under both methods. To explore the pipeline’s sensitivity, we consider five dimensions that have a demonstrable impact on CMC counts: the decision rule (original or High CMC) used, whether the global trend is removed during pre-processing, and choice of congruency thresholds: translation \\(T_x, T_y\\), rotation \\(T_\\theta\\), and cross-correlation \\(T_{\\text{CCF}}\\). Choosing a single parameter setting that results in perfect identification is not enough to generally understand the algorithm. Instead, we use the variance ratio \\(r\\) to identify promising ranges of parameters. Figure 2.13 shows the value of the variance ratio under different parameter settings. We see that the High CMC decision rule yields better separation than the original decision rule under any parameter setting. The largest variance ratio values are achieved for thresholds \\(T_x, T_y \\in [10,20]\\), \\(T_\\theta = 6\\), and \\(T_{\\text{CCF}} \\in [0.4,0.5]\\). Interestingly, considering Table 2.3, only the parameters used in Song et al. (2018) fall into these ranges. Figure 2.13: Variance ratio values are plotted for different parameter settings. High variance ratios are indicative of a a good separation between CMC counts for known matching pairs and known-non matching pairs. The High CMC decision rule generally performs better than the original decision rule. Removing the trend during pre-processing has a major impact on the effectiveness of the CMC pipeline. In this setting, translation thresholds \\(T_x, T_y \\in [15,20]\\), a rotation threshold \\(T_\\theta = 6\\), and a CCF threshold \\(T_{\\text{CCF}} \\in [0.4,0.5]\\) lead to a separation of results. As shown in Figure 2.13, de-trending breech-scans in the pre-processing stage emerges as a critical step to achieve good algorithmic results. This step is not explicitly mentioned in the written-word descriptions of the algorithm in Song (2013), Tong et al. (2014), Tong, Song, and Chu (2015), Chen et al. (2017), or Song et al. (2018), though it appears from their examples that it was used in the process. Figure 2.13 also illustrates how breaking a pipeline up into modularized steps eases experimentation. We will expand upon this idea in the next section. We compare the best results from cmcR to results presented in previous papers. In particular, we have calculated variance ratio statistics shown in Figure 2.14 based on CMC counts reported in Song (2013), Tong et al. (2014), Tong, Song, and Chu (2015), Chen et al. (2017), and Song et al. (2018). The last row in each facet shows the variance ratio values obtained from cmcR. We see that the implementation provided in cmcR yields comparable results to previous CMC papers. Figure 2.14: Variance ratios based on results reported in various CMC papers. The High CMC decision rule tends to outperform the original decision rule. However, it should be emphasized that each paper uses very different processing and parameter settings meaning the results are difficult to compare. The values labeled “cmcR” show the largest variance ratio values for the original and High CMC decision rules based on a limited grid search. These results indicate that the CMC pipeline implementation provided in cmcR yields comparable results to previous CMC papers. 2.4 Conclusion Reproducibility is an indispensable component of scientific validity (Goodman, Fanelli, and Ioannidis 2016). In this paper, we demonstrate at least three ways reproducibility can go awry: ambiguity in procedural implementation, missing or incomplete data, and missing or incomplete code. In forensics, many matching algorithms are commonly presented in the form of conceptual descriptions with accompanying results. There is sound reasoning to this; conceptual descriptions are more easily understood by humans compared to computer code. However, using the CMC pipelines as an example we have observed the gaps that can exist when translating a conceptual description of an algorithm to a genuine implementation. This is largely due to the fact that conceptual descriptions rarely detail implicit parameter choices required to run an algorithm. Consequently, there are multiple choices that are compatible with the description of an algorithm in a publication. This is dangerous in a forensics context because if many parameter settings are valid but only a narrow range lead to the same conclusion, it is entirely possible that witnesses for the prosecution and defense comef to different conclusions. In order to prevent such misunderstandings, it is not enough to have guidelines for parameter settings and/or a sensitivity study – it is also necessary to standardize the specific computer code. The parameter values are only useful within the context of a single software package or pipeline. These principles of open, accessible, interoperable code are also critical for a fair (in the legal sense) justice system: the defense has access to the code to understand the evidence against them, lawyers and examiners can assess the utility of the analysis method, and judges can determine whether a method is admissible in court. Transparent and intuitive open-source algorithms, such as cmcR, should be considered the gold standard in allowing the forensic science community to validate a pipeline. Our contribution to the CMC literature is the open-source implementation, which fills the gaps in the human-friendly descriptions in the original papers. In addition, because we have structured the cmcR implementation as a modular pipeline, it is easier to improve upon the CMC method and document the effects of specific changes to the algorithm compared to previous versions. The modularization creates an explicit framework to assess the utility and effectiveness of each piece of the algorithm, and allows us to independently manipulate each step while monitoring the downstream impact on the results. Additionally, it allows future collaborators to improve on pieces of the pipeline, adding new options and improving the method without having to re-invent the wheel. Indeed, re-implementing steps of the pipeline is at best a useful academic exercise and at worst a waste of time and resources that could be spent actually improving the pipeline. Even after many months of trial and error, although we have succeeded in obtaining qualitatively similar results on two data sets, it is difficult to know whether our implementation will behave the same as previous implementations on external data sets. Generalizability is an important assessment for any computational algorithm (Vanderplas et al. 2020). Our application is far from unique: some journals have adopted policies encouraging or requiring that authors provide code and data sufficient to reproduce the statistical analyses, with the goal of building a “culture of reproducibility” in their respective fields (Peng 2009, 2011; Stodden, Guo, and Ma 2013). Peer-review and scientific progress in the truest sense requires that all pre-processed data, code, and results be made openly available (Kwong 2017; Desai and Kroll 2017). Our experience with the CMC algorithm suggests that these standards should be adopted by the forensic science community, leveraging open-source ecosystems like R and software sharing platforms such as Github. We firmly believe that the forensic community should not go only halfway, trading a subjective, human black box for objective, proprietary algorithms that are similarly opaque and unauditable. Open, fully reproducible packages like cmcR allow research groups to make incremental changes, compare different approaches, and accelerate the pace of research and development. 2.5 Acknowledgement This work was partially funded by the Center for Statistics and Applications in Forensic Evidence (CSAFE) through Cooperative Agreement 70NANB20H019 between NIST and Iowa State University, which includes activities carried out at Carnegie Mellon University, Duke University, University of California Irvine, University of Virginia, West Virginia University, University of Pennsylvania, Swarthmore College and University of Nebraska, Lincoln. We greatly appreciate the constructive feedback from the two anonymous reviewers. Special thanks also to all the developers and open-source contributors of R, knitr (Xie 2015, 2014), rticles (Allaire et al. 2021), and the tidyverse (Wickham et al. 2019), without whom this project would not have been possible. 2.6 Computational details #&gt; R version 4.2.2 (2022-10-31 ucrt) #&gt; Platform: x86_64-w64-mingw32/x64 (64-bit) #&gt; Running under: Windows 10 x64 (build 22621) #&gt; #&gt; Matrix products: default #&gt; #&gt; locale: #&gt; [1] LC_COLLATE=English_United States.utf8 #&gt; [2] LC_CTYPE=English_United States.utf8 #&gt; [3] LC_MONETARY=English_United States.utf8 #&gt; [4] LC_NUMERIC=C #&gt; [5] LC_TIME=English_United States.utf8 #&gt; #&gt; attached base packages: #&gt; [1] stats graphics grDevices datasets utils methods #&gt; [7] base #&gt; #&gt; other attached packages: #&gt; [1] patchwork_1.1.2 rgl_1.0.1 x3ptools_0.0.3 lubridate_1.9.2 #&gt; [5] forcats_1.0.0 stringr_1.5.0 purrr_1.0.1 readr_2.1.4 #&gt; [9] tidyr_1.3.0 tibble_3.2.0 tidyverse_2.0.0 cmcR_0.1.11 #&gt; [13] dplyr_1.1.0 magrittr_2.0.3 ggplot2_3.4.1 #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] webshot_0.5.4 httr_1.4.5 tools_4.2.2 #&gt; [4] bslib_0.3.1 utf8_1.2.2 R6_2.5.1 #&gt; [7] colorspace_2.0-3 withr_2.5.0 readbitmap_0.1.5 #&gt; [10] tidyselect_1.2.0 gridExtra_2.3 compiler_4.2.2 #&gt; [13] textshaping_0.3.6 cli_3.6.0 rvest_1.0.3 #&gt; [16] quantreg_5.94 SparseM_1.81 xml2_1.3.3 #&gt; [19] labeling_0.4.2 bookdown_0.26 sass_0.4.1 #&gt; [22] scales_1.2.0 systemfonts_1.0.4 digest_0.6.29 #&gt; [25] tiff_0.1-11 yulab.utils_0.0.6 rmarkdown_2.14 #&gt; [28] svglite_2.1.1 base64enc_0.1-3 jpeg_0.1-10 #&gt; [31] pkgconfig_2.0.3 htmltools_0.5.4 fastmap_1.1.0 #&gt; [34] highr_0.9 htmlwidgets_1.6.1 rlang_1.0.6 #&gt; [37] rstudioapi_0.14 gridGraphics_0.5-1 jquerylib_0.1.4 #&gt; [40] farver_2.1.0 generics_0.1.2 zoo_1.8-11 #&gt; [43] jsonlite_1.8.4 kableExtra_1.3.4 ggplotify_0.1.0 #&gt; [46] Matrix_1.5-3 Rcpp_1.0.10 munsell_0.5.0 #&gt; [49] fansi_1.0.3 ggnewscale_0.4.8 lifecycle_1.0.3 #&gt; [52] stringi_1.7.6 yaml_2.3.5 MASS_7.3-55 #&gt; [55] grid_4.2.2 lattice_0.20-45 cowplot_1.1.1 #&gt; [58] splines_4.2.2 hms_1.1.2 knitr_1.39 #&gt; [61] pillar_1.8.1 igraph_1.4.1 codetools_0.2-18 #&gt; [64] imager_0.42.18 glue_1.6.2 evaluate_0.15 #&gt; [67] bmp_0.3 renv_0.17.0 png_0.1-8 #&gt; [70] vctrs_0.5.2 tzdb_0.3.0 MatrixModels_0.5-1 #&gt; [73] gtable_0.3.0 assertthat_0.2.1 xfun_0.31 #&gt; [76] pracma_2.4.2 ragg_1.2.5 survival_3.4-0 #&gt; [79] viridisLite_0.4.0 timechange_0.2.0 ellipsis_0.3.2 References "],["diagnostic-tools-for-cartridge-case-comparison-algorithms.html", "3 Diagnostic Tools for Cartridge Case Comparison Algorithms Abstract 3.1 Introduction", " 3 Diagnostic Tools for Cartridge Case Comparison Algorithms Abstract Diagnostics are useful for explaining the behavior of a complex model or algorithm. In this paper, we introduce a suite of visual and interactive diagnostic tools to assess algorithms that automatically compare forensic cartridge case evidence. These tools are useful to both forensic researchers and practitioners: Researchers can analyze and correct the (mis)behavior of the algorithm forensic practitioners can more easily understand and explain the algorithm. First, we develop a collection of tools to diagnose each step of a cartridge case comparison algorithm in the impression R package. We then implement these visual diagnostics in an interactive web application called cartridgeInvestigatR to provide greater flexibility to the user. 3.1 Introduction Start of paper. "],["automatic-matching-of-cartridge-case-impressions.html", "4 Automatic Matching of Cartridge Case Impressions Abstract 4.1 Introduction", " 4 Automatic Matching of Cartridge Case Impressions Abstract Forensic examinations attempt to solve the binary classification problem of whether two pieces of evidence originated from the same source. For example, a cartridge case found at a crime scene may be compared to a cartridge case fired from a suspect’s firearm. Forensic examiners traditionally rely on high-powered comparison microscopes, case facts, and their own experience to arrive at a source conclusion. Recently, algorithms that provide an automatic and objective measure of similarity of the evidence have become more prevalent. We introduce the Automatic Cartridge Evidence Scoring (ACES) algorithm that encompasses preprocessing, feature extraction, and similarity scoring. Our primary contribution is a set of features used to classify whether two cartridge cases were fired from the same firearm. We use a train/test split on a data set of 510 cartridge case scans to fit and validate random forest, logistic regression, and Classification and Regression Tree (CART) models. We demonstrate that these models are more accurate than predominant algorithms on our data set. 4.1 Introduction Start of paper. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
